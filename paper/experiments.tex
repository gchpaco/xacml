\section{Experiments}
\label{sec:experiments}

Our tool generates a Boolean formula in Conjunctive Normal Form, which
we then give to a SAT solver; in particular, we use the
\texttt{zchaff}~\cite{moskewicz01chaff} tool.  To demonstrate the
value of this tool, we use the \textsc{Continue}
example~\cite{krishnamurthi03continue}, encoded into XACML by Fisler
et al.~\cite{fisler05}.  \textsc{Continue} is a Web-based conference
management tool, aiding paper submission, review, discussion and
notification.  Additionally, we have used the Medico example from the
XACML~\cite{xacml} specification, which models a simple medical
database meant to be accessed by physicians.  Finally, we have encoded
our running example into XACML and applied our tool to the discovery
of the error.

\begin{table*}[t]
\centering
\begin{tabular}{c|cccc|cc|c}
  Property & IO & Transform & Boolean & SAT & Variables
  & Clauses & Result \\
  \hline
% unsat
  C1 & 1.85 & 0.17 & 1.35 & 0.11 & 56 & 114 & No \\
  C2 & 2.07 & 0.19 & 1.41 & 0.39 & 42 & 83  & No \\
  C3 & 1.88 & 0.16 & 1.36 & 0.12 & 51 & 108 & No \\
  C4 & 1.94 & 0.17 & 1.33 & 0.11 & 52 & 106 & No \\
  C5 & 1.82 & 0.16 & 2.00 & 0.16 & 79 & 166 & No \\
  \hline
% sat
  C6 & 2.12 & 0.15 & 2.53 & 0.15 & 89 & 190 & Yes \\
  C7 & 2.56 & 0.34 & 3.70 & 0.10 & 95 & 218 & Yes  \\
  C8 & 1.99 & 0.18 & 1.21 & 0.11 & 42 & 83 & Yes \\
  C9 & 1.92 & 0.16 & 1.49 & 0.11 & 51 & 106 & Yes \\
  C10 & 1.88 & 0.19 & 3.47 & 0.11 & 108 & 250 & Yes \\
  C11 & 1.89 & 0.16 & 5.18 & 0.15 & 129 & 297& Yes \\
  \hline
  M1 & 0.75 & 0.02 & 15.10 & 0.22 & 109 & 280 & No \\
  M2 & 1.00 & 0.03 & 14.78 & 0.13 & 108 & 279 & No \\
\hline
  V1 & 0.73 & 0.14 & 5.86 & 0.12 & 52 & 123 & Yes \\
\end{tabular}
\caption{Verification performance for the 
  properties of conference manager (C1-11), medico (M1-2) and
  voting (V1) examples. 
  We divided the execution time to I/O, tranformation
  to triple form, Boolean formula generation and CNF transformation 
  and SAT solving.
  The times are in seconds.
  We also listed the size of the generated SAT problem instance 
  (in terms of the number of Boolean variables and clauses)
  for verification of each property.
  If the result is ``Yes'' the generated SAT instance is satisfiable
  and the property is violated. 
  If the result is ``No'' the generated SAT instance is not satisfiable
  and the property holds.
}
\label{tbl:bigdata}
\end{table*}

We tested 11 properties, labelled C1, C2, and so on, for subsumption
on \textsc{Continue} and two, labelled M1 and M2 on the Medico
example; our voting example is property V1.  Run times for
verification are given in Table~\ref{tbl:bigdata}.  In detail:
\begin{enumerate}
\item Property C1 tests whether the conference manager denies program
  committee chairs the ability to review papers he/she has a conflict
  with.
\item Property C2 and C7 test two related properties concerning
  reviews for papers a program committee member reviews that he/she
  owns.
\item Property C3 and C8 test two related properties concerning access
  to the conference manager if the user has no defined role.
\item Property C4 and C5 test two related properties regarding read
  access to information about meetings.
\item Property C6 tests whether program committee members can read
  all parts of a review.
\item Property C9 tests which roles can set meetings.
\item Property C10 and C11 test under what conditions program
  committee members can see reviews.
\item Property M1 and M2 test whether the unified Medico policy
  upholds some important access properties.
\item Property V1 is just the voting property we demonstrated in
  Section~\ref{sec:properties-policies}.
\end{enumerate}
Some of these properties are expected to be subsumed by the
\textsc{Continue} policy, and some are expected to subsume the policy.
In general, if one wishes to verify that a property is upheld for any
potential outcome, one should write a policy that is expected to
subsume the target policy.  Existence properties are most readily
demonstrated with policies that are expected to be subsumed by the
target policy.

In general, analysis time is dominated by the initial parsing of the
policies and by the conversion from triple form to a Boolean formula;
sometimes the Boolean conversion is strongly dominant, as in the
Medico examples.  The resulting formulas are unexpectedly small and
analysis time is so small the startup and I/O overhead of the
\texttt{zchaff} tool is probably dominating.  This was unexpected; our
tool goes to some length to simplify the Boolean formula on the
assumption that run times would be dominated by the SAT solver, which
is clearly wrong.

The number of variables in our Boolean formulas is quite large,
approximately half the number of clauses.  We have made a deliberate
tradeoff to get this; our translation machinery from
Section~\ref{sec:autom-prov-prop} introduces large numbers of tightly
constrained variables, and our CNF conversion uses the structure
preserving technique~\cite{plaisted86structure} which generates even
more variables, but in exchange we get a relatively small formula, and
the search space is not so large as might be presumed because of the
constraints.  A different CNF conversion might embody a different
tradeoff that might be worth exploring.

This data clearly demonstrates that the subsumption property is
practical to analyze, and we believe total runtime could be lowered
through different techniques.

% arch-tag: 5a3a4d97-641f-4c94-804d-9ec83256e4e6

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
