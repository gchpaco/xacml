\section{Introduction}

Keeping track of permission grants, organizational policies and
special cases in a modern software system has become difficult enough
on its own; keeping the policy consistent across multiple
heterogeneous systems is even more difficult, as each system requires
that these grants and policies be expressed in its own specific
control language.  Several unified access policy languages address
this problem.  If all the systems use the same access policy language,
then access policies need only be written once and similarly only one
policy needs to be kept up to date.  In this paper we focus on one
particular such language, the OASIS standard XACML~\cite{xacml}.

OASIS (the Organization for the Advancement of Structured Information
Standards) is an international standards consortium noted particularly
for work in the popular markup language XML~\cite{XML}.  They have
published a standard for access policy languages called XACML
(expanded as ``eXtensible Access Control Markup Language''), which we
will discuss in detail below.  For the moment, it suffices to describe
it as an XML-based language for expressing access rights to arbitrary
objects that are identified in XML, with a particular focus on the
composition of many different subpolicies into a single superpolicy.

Having such a combined policy is convenient, but such a policy will
inevitably become quite large and complex as all an organization's
rules get placed in it.  It is possible, even likely, that the act of
creating a unified policy out of numerous disparate smaller policies
could leave it vulnerable to unintended consequences.  In this paper
we investigate statically verifying properties of access control
policies to prevent such errors. We translate XACML policies into a
simplified mathematical model, which we reduce to a normal form
separating the conditions that give rise to {\em access permitted},
{\em access denied}, and {\em internal error} results. We define
partial orderings between access control policies, with the intention
of checking whether a policy is over- or under constrained with
respect to another one.  We show that these ordering relations can be
translated to Boolean formulas which are satisfiable if and only
if the corresponding relation is violated.  We use a SAT solver to check
satisfiablity of these Boolean logic formulas. Using our
translator and a SAT solver we can check if a combination of XACML
policies does or does not faithfully reproduce the properties of its
subpolicies, and thus discover unintended consequences before they
appear in practice.

In Section~\ref{sec:policy-spec}, after giving an overview of XACML,
we develop a formal model for access policies; in
Section~\ref{sec:transformations} we discuss how to transform these
models into a normal form that distinguishes access permitted, access
denied, and error conditions.  In
Section~\ref{sec:properties-policies} we define partial ordering
relations among access policies which are used to specify their
properties.  We show how to check these properties automatically in
Section~\ref{sec:autom-prov-prop}.  Finally, we report the results of
our experiments in Section~\ref{sec:experiments}.


% arch-tag: 964a775e-9547-4b64-a0f7-ebf78d282c99

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
