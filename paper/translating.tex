\section{Automatically Proving Properties of Policies}
\label{sec:autom-prov-prop}

Given the formal model defined in Section~\ref{sec:formal-model} and
properties defined in Section~\ref{sec:properties-policies} we would
like to check properties of access policies automatically.  To do this
we first formalize the syntax of formulas we use to specify subsets of
$E$.  Then we discuss how policies constructed using these formulas
and policy combinators can be translated to the Alloy language.  One
can check properties of access policies by translating them to SAT
problems.  Instead of targeting a SAT problem directly, our translator
targets the Alloy language, which is in turn translated into a SAT
problem by the Alloy Analyzer.  This approach simplifies our
translator and permits us to remain closer to the syntax of the
original problem statement.

\subsection{Policy Classes}
\label{sec:policy-classes}

In Section~\ref{sec:formal-model}, we defined our formal model using
subsets of $E$ for the definition of \Scope and \Err.  Since $E$ is
the Cartesian product of the power sets of what are in most cases
infinite sets, analyzing these properties would seem to require
enumerating these subsets, an impossible job.  Fortunately, we are
translating from XACML to our foreign model, and totally arbitrary
subsets are not possible in XACML.  We can structure the subsets we
will get from XACML policies in a more useful fashion: they end up
looking like the sets $S_0, S_1, \dots, S_4$ in
Equation~\eqref{eq:s0}.

To formalize this, we fix the following notational conveniences: for
elements $e \in E$, we name the components of $e$ $e[0], e[1], \dots,
e[n]$.  We use $s, s_0, s_1, \dots, s_n$ to denote set variables, $c,
c_0, c_1, \dots, c_n$ to denote scalar variables, and $C, C_0, C_1,
\dots, C_n$ to denote constants.  Finally, $BP$ is a set of basic
predicates which we will define below.  We fix our structure in the
following fashion: all subsets of $E$ are specified in the form $\{ e
\in E : P \}$, where there are no free variables save $e$ in $P$ and
$P$ is defined as follows:
\begin{eqnarray*}
  P & \rightarrow & BP \quad | \quad \forall c \in s \; P \quad |
  \quad \exists c \in s \; P \\
  & | & \exists ! \, c \in s \; P \quad | \quad \exists ! \, c \in e[i] \; P \\
  & | & P \wedge P \quad | \quad P \vee P \quad | \quad \neg P
\end{eqnarray*}

Below, we will define four different basic predicate sets with
increasing expressive power, such that $BP_1 \subseteq BP_2 \subseteq
BP_3 \subseteq BP_4$.  The version of $BP$ that used is important for
translation. For example, if a policy can be written using only
predicates from $BP_1$ then we can make certain guarantees about its
translation that may not hold if we must simulate predicates from a
larger $BP$.

Our first class is that of policies using only enumerated types (which
obviously have finite domains) and the simple operations $\neg$, $=$,
$\in$, $\subseteq$.  We define the first class of basic predicates,
$BP_1$, as follows:
\begin{eqnarray*}
  SCAL & \rightarrow & c \quad | \quad C \\
  BSET & \rightarrow & s \quad | \quad e[i] \\
  SET & \rightarrow & SET \cup SET \quad | \quad SET \cap SET \\
  & | & SET \setminus SET \quad | \quad \{ SCAL \} \quad | \quad BSET \\
  BP_1 & \rightarrow & SET \subseteq SET \quad | \quad SCAL \in SET \\
  & | & SCAL = SCAL \quad | \quad \texttt{true} \quad | \quad \texttt{false}
\end{eqnarray*}
We can express all set definitions on unordered and enumerated types
that are permitted in XACML using the expressions above.

Given a set in the form $S = \{ e \in E : P \}$ where $P$ is defined
based on the above syntax, one can generate a boolean logic formula
$B$ which encodes the set $S$.  The encoding will map each $e \in E$
to a valuation of the boolean variables in $B$ and $B$ will evaluate
to true if and only if $e \in S$.  Based on such an encoding we can
convert questions about different policies (such as if one subsumes
the other one) to SAT problems and then use a SAT solver to check
them.  For example, we can generate a boolean formula which is
satisfiable if and only if an access policy is subsumed (i.e.,
$\sqsubseteq$) by another one.  If the SAT solver returns a satisfying
assignment to the formula, then we can conclude that the property is
false, and generate a counterexample based on the satisfying
assignment.  If the SAT solver declares that the formula is not
satisfiable then we can conclude that the property holds.  Details of
such a translation for the Alloy language is given
in~\cite{jackson00automating}, and as we will show below the policies
specified with the syntax described above can be translated to Alloy
language.

The second class of basic predicates extends the first one to handle
types which have a total order relation $<$, as well.  We define
$BP_2$ as follows:
\begin{eqnarray*}
 BP_2 & \rightarrow & BP_1 \quad | \quad SCAL < SCAL 
\end{eqnarray*}
Sets described using this class of predicates can also be translated
to a boolean logic formula. We can encode a type with a domain of $n$
ordered elements using $n^2$ boolean variables, one for each pair of
values in the domain.

The third class of policies extends the second class to include
infinite domains. Although the syntax for $BP_2$ and $BP_3$ are the
same for $BP_3$ we permit $E$ to be composed of power sets of infinite
domains.  Note that we cannot translate sets described using such
predicates directly to boolean logic formulas.  So instead we limit
the scope of our investigations: we artificially limit the size of the
set to a given fixed size and then perform analysis upon it as though
it were a finite enumerated set of that size. The problem is that if
no counterexample is found, then that does not necessarily mean that
no counterexample exists---perhaps if we had increased the scope just
a little more we would have found one. The small scope hypothesis
(discussed in~\cite{jackson:elements}, and tested and confirmed for
some data structure algorithms in~\cite{marinov:exhaustive}) suggests
that small scopes could be sufficient in practice. Note that if a
counterexample is found, that counterexample is definite and can be
translated into an error in the original policy.

The fourth and final class of policies extends the third class to
handle arbitrary Boolean functions, with any scalars or sets as
arguments. We also handle one special function on sets, that being the
magnitude operation.
\begin{eqnarray*}
  BP_4 & \rightarrow & BP_3 \quad | \quad f (SET, \dots, SCAL, \dots)
\quad | \quad | SET | 
\end{eqnarray*}
To translate sets described using such predicates to boolean logic
formulas we use uninterpreted functions, i.e., we create a Boolean
variable for encoding the value of a boolean function and we create a
(bounded) integer variable for encoding the size of set. We generate
constraints which guarantee that the value of the function is the same
if its arguments are the same. Other than this restriction the
variables encoding the functions can get arbitrary values.  Note that
this brings an extra level of imprecision to our analysis.  We were
not able to trust the positive results because of the scope
restriction, but now it is also possible that counterexamples may be
spurious, and will need to be validated against the original policy.
However, we think that such automated analysis can still be useful in
uncovering errors in access policies.

The above suffices for modeling every function in core XACML, with the
exception of the higher order functions.  Those functions invariably
operate on sets, complicate the analysis, and---if these functions are
restricted to using the predicates that we can model directly---can
ultimately be expressed using the predicates we can already handle.

In the above we defined the syntax for four policy classes and argued
that properties of policies described with the above syntax can be
translated to SAT problems.  Our analysis tool instead targets the
modeling language
Alloy~\cite{jackson:alcoa,jackson:micromodels,jackson00automating}.
Alloy permits a more literal translation of our model, simplifying the
translation tremendously. After introducing Alloy briefly, we will
show how we translate our four classes of policies to Alloy.

\subsection{Alloy}

Alloy is a declarative modeling language out of MIT equipped with an
analyzer that can verify assertions about models written in the
language.  Alloy analyzer achieves this by converting assertions to
Boolean logic formulas which are fed to a SAT solver.  Alloy is based
in first order relational logic, and is intended to model complex
structures. It does so through extensive set manipulation, and this
manipulation permits an easy translation from our mathematical model.
Alloy has been used to automatically extract object
models~\cite{jackson01lightweight,waingold01automated}, to analyze the
behavior of filesystem synchronization
utilities~\cite{nolte02filesystem}, to model virtual
functions~\cite{marinov02valloy} and to automatically check structural
properties of data on the heap~\cite{vaziri03heap}.

Alloy models consist of sets of concrete objects, called
\emph{signatures}, facts about these sets, and relations on these
sets.  Distinguished subsets of signatures are possible; these new
signatures are said to \emph{extend} the superset.  Unlike some other
modeling languages, Alloy does not require that these relations be
completely specified.  After defining signatures and facts about them,
one can ask Alloy to verify that certain properties hold in all
possible models that conform to the facts given, or that there exists
a model capable of satisfying all the facts given.  Alloy cannot, in
general, prove assertions about all possible models; it can, however,
prove assertions for all models within a fixed scope, which is what we
have to settle for analyzing access policies in general as well.

One oddity about Alloy is that it unifies singleton sets and scalars;
this is done for technical reasons, but it has some implications for
our translation that will be discussed in the next section as they
arise.

\subsection{Translation to Alloy}
\label{sec:translation-alloy}

The general structure we will be using here is as follows: to prove
that $P_1 \sqsubseteq P_2$, we need to prove that each individual
component of $P_1$ is a subset of each individual component of $P_2$.
This part of the generated Alloy code is as follows:
\begin{verbatim}
static sig P1 extends Triple {} {
    ...
}
static sig P2 extends Triple {} {
    ...
}
assert Subset {
    P1.permit in P2.permit
    P1.deny in P2.deny
    P1.error in P2.error
}
\end{verbatim}
That is, we define two models \texttt{P1} and \texttt{P2}, and then
check that the components of the one are contained in the other.
Since Alloy unifies sets and singletons, \texttt{in} can do double
duty as set membership and subset testing.  Similarly we do not need
to specifically handle the conversion of scalar variables to singleton
sets.

We can translate $P_1$ and $P_2$ in our mathematical model in the
following manner. First, we distinguish predicates outside of
existential and universal quantifiers from predicates inside: that is,
we split $P$ into $P'$ and $P''$ as follows:
\begin{eqnarray*}
  P' & \rightarrow & BP \quad | \quad \forall c \in s \; P'' \quad |
  \quad \exists c \in s \; P'' \\
  & | & \exists ! \, c \in s \; P'' \quad | 
  \quad \exists ! \, c \in e[i] \; P'' \\
  & | & P' \wedge P' \quad | \quad P' \vee P' \quad | \quad \neg P'' \\
  P'' & \rightarrow & BP \quad | \quad \forall c \in s \; P'' \quad |
  \quad \exists c \in s \; P'' \\
  & | & \exists ! \, c \in s \; P'' \quad | \quad 
  \exists ! \, c \in e[i] \; P'' \\
  & | & P'' \wedge P'' \quad | \quad P'' \vee P'' \quad | \quad \neg P''
\end{eqnarray*}
We translate tuples according to the rules in
Figure~\ref{fig:alloy-translation}, and some of these tuples will
create auxiliary sets much like the sets $S_0, S_1, S_2, S_3$
(Equations ~\eqref{eq:s1} to ~\eqref{eq:s4}) we used in
Section~\ref{sec:formal-model}.  The function $\extract$ defines a new
subset of the environment \texttt{E} based on its argument (which is a
formula) and then returns the name of this subset.  So $\extract(e)$
would return \texttt{S$_i$} and generate the following definition:
\verb|sig S|$_i$ \verb|extends E {} {| $e$ \verb|}|.

\begin{figure}[t]
\[
\begin{array}{l}
 \translation(\langle r, s, t \rangle) \Rightarrow
  \begin{aligned}
    \mtt{permit = } \translation_{P'} (r) \\
    \mtt{deny = } \translation_{P'} (s) \\
    \mtt{error = } \translation_{P'} (t)
  \end{aligned} \nonumber \\
  \\
  \mbox{For predicates outside quantifier formulas} \\
  \translation_{P'} (P'_1 \cap P'_2) \Rightarrow  
  \translation_{P'} (P'_1) \mtt{ \& } \translation_{P'} (P'_2) \nonumber \\
  \translation_{P'} (P'_1 \cup P'_2) \Rightarrow  
  \translation_{P'} (P'_1) \mtt{ + } \translation_{P'} (P'_2) \nonumber \\
  \translation_{P'} (\neg P'_1) \Rightarrow  
  \mtt{E - } \translation_{P'} (P'_1) \\ % \label{eq:6} \\
  \translation_{P'} (\forall c \in s \; P'') \Rightarrow 
  \extract(\mtt{all } c \mtt{:} \translation_{P''} (s)  \\
   \qquad \qquad \qquad \qquad \qquad
              \mtt{ | } \translation_{P''} (P'')) \\ %\label{eq:2} \\
  \translation_{P'} (\exists c \in s \; P'') \Rightarrow 
  \extract(\mtt{some } c \mtt{:} \translation_{P''} (s) \\
  \qquad \qquad \qquad \qquad \qquad \mtt{ | }
  \translation_{P''} (P'')) \nonumber \\
  \translation_{P'} (\exists ! \, c \in s \; P'') \Rightarrow 
  \extract(\mtt{one } c \mtt{:} \translation_{P''} (s) \\
  \qquad \qquad \qquad \qquad \qquad \mtt{ | }
  \translation_{P''} (P'')) \nonumber \\
  \translation_{P'} (BP) \Rightarrow  \translation_{BP} (BP) \nonumber \\
  \\
  \mbox{For predicates inside quantifier formulas} \\
  \translation_{P''} (P''_1 \cap P''_2) \Rightarrow  
  \translation_{P''} (P''_1) \mtt{ \&\& } \translation_{P''} (P''_2) 
  \nonumber \\
  \translation_{P''} (P''_1 \cup P''_2) \Rightarrow  
  \translation_{P''} (P''_1) \mtt{ || } \translation_{P''} (P''_2) \nonumber \\
  \translation_{P''} (\neg P''_1) \Rightarrow  
  \mtt{!} \translation_{P''} (P''_1) \nonumber \\
  \translation_{P''} (\forall c \in s \; P'') \Rightarrow 
  \extract(\mtt{all } c \mtt{:} \translation_{P''} (s) \\
   \qquad \qquad \qquad \qquad \qquad \mtt{ | }
  \translation_{P''} (P'')) \\ % \label{eq:1} \\
  \translation_{P''} (\exists c \in s \; P'') \Rightarrow 
  \extract(\mtt{some } c \mtt{:} \translation_{P''} (s) \\
   \qquad \qquad \qquad \qquad \qquad \mtt{ | }
  \translation_{P''} (P'')) \nonumber \\
  \translation_{P''} (\exists ! \, c \in s \; P'') \Rightarrow 
  \extract(\mtt{one } c \mtt{:} \translation_{P''} (s) \\
  \qquad \qquad \qquad \qquad \qquad \mtt{ | }
  \translation_{P''} (P'')) \nonumber \\
  \translation_{P''} (BP) \Rightarrow  \translation_{BP} (BP) \nonumber
\end{array}
\]
\caption{Basic translation rules}
\label{fig:alloy-translation}
\end{figure}

Now, we just need to know how to translate the $BP$ hierarchy to
Alloy.  Translating the various sorts of basic predicates in $BP_1$ is
straightforward but has minor complications: Alloy equates scalar
quantities and sets with only one element. So, $\subseteq$ is the same
operation as $\in$. To create constant elements, we create a field in
a structure composed entirely of static constants which looks like:
\begin{verbatim}
static sig CONSTANTS {
    x1 : scalar Integer,
    x2 : scalar Integer,
    ...
}
\end{verbatim}
We use $\constant (C)$ to describe the operation that inserts the
constant $C$ into this table if it is not already present, and returns
a name to refer to it (for example, \texttt{CONSTANTS.x1} for the
first field).  Since the Boolean constants \texttt{True} and
\texttt{False} are already defined in Alloy we do not need to go
through this operation for Boolean constants, and can translate those
directly.

The $e[i]$'s are represented as fields of the \texttt{E} structure
which is declared as:
\begin{verbatim}
sig E {
    age : set Integer,
    voted : set Bool,
    actions : set String
}
\end{verbatim}
for the environment $E$ defined in Equation~(\ref{eqn:env}) for our
running example.  We use $\env (e[i])$ to give the translation for the
environmental set $e[i]$. For the running example, $\env (e[0]) =
\mtt{age}$ and $\env (e[2]) = \mtt{actions}$.

The total translation for $BP_1$ can be done as follows:
\begin{align}
  \translation_{BP} (s) \Rightarrow & s \nonumber \\
  \translation_{BP} (c) \Rightarrow & c \nonumber \\
  \translation_{BP} (e[i]) \Rightarrow & \env (e[i]) \nonumber \\ 
              % \label{eq:5} \\
  \translation_{BP} (C) \Rightarrow & \constant (C) \nonumber \\
  \translation_{BP} (s_i \cup s_j) \Rightarrow & \translation(s_i) \mtt{ + }
  \translation_{BP} (s_j) \nonumber \\
  \translation_{BP} (s_i \cap s_j) \Rightarrow & \translation(s_i) \mtt{ \& }
  \translation_{BP} (s_j) \nonumber \\
  \translation_{BP} (s_i \setminus s_j) \Rightarrow & \translation(s_i)
  \mtt{ - } \translation_{BP} (s_j) \nonumber \\
  \translation_{BP} (\{ c \}) \Rightarrow & \translation(c) \nonumber \\
  \translation_{BP} (c_i = c_j) \Rightarrow & \translation(c_i) \mtt{ = }
  \translation_{BP} (c_j) \nonumber \\
  \translation_{BP} (c \in s) \Rightarrow & \translation(c) \mtt{ in }
  \translation_{BP} (s) \nonumber \\
  \translation_{BP} (s_i \subseteq s_j) \Rightarrow & \translation(s_i)
  \mtt{ in } \translation_{BP} (s_j) \nonumber
\end{align}
Using all of this, we can show as an example, a translation of $S_1$
in Equation~(\ref{eq:s1}) into Alloy which results in:
\begin{verbatim}
sig S1 extends E {} { all x : voted | x = False }
\end{verbatim}
For policies of the second class, we add the predicate $<$.  To
accommodate this, we define an Alloy function \texttt{LessThan} and
enforce its transitivity as follows:
\begin{verbatim}
fact {
    all a,b,c:Type {
        LessThan (a, b) = True && 
        LessThan (b, c) = True => 
            LessThan (a, c) = True
    }
}
\end{verbatim}
Now we can simply translate
\begin{multline*}
  \translation(a < b) \Rightarrow \\
  \mtt{LessThan} (\translation(a), \translation(b)) \mtt{ = True}
\end{multline*}
As an example, we translate $S_0$ in Equation~(\ref{eq:s0}) which
looks like:
\begin{verbatim}
static sig CONSTANTS {
    x1 : scalar Integer
}
sig S1 extends E {} { all x : age | 
    LessThan (a, CONSTANTS.x1) = True }
\end{verbatim}
Policies of the third class require no special translation; they
merely require that Alloy be informed of the scope requirements when
it attempts to analyze the policy.

Policies of the fourth class are accommodated by defining a new Alloy
relation about which we specify nothing.  For example, suppose we
wanted to analyze a policy involving XACML's embedded XPath matching.
Since we will encode this as an uninterpreted function all we need to
know about XPath matching is that it returns a Boolean value. We
define a set $S_6$ as follows:
\begin{equation*}
  S_6 = \{ \langle a, v, o \rangle \in E : \mtt{xpathnodematch}
  (\mtt{/actions}, o) \}
\end{equation*}
where {\tt /actions} is an XPath expression.  We translate this by
first introducing a new function as follows:
\begin{verbatim}
static sig Functions {
    // xpathnodematch(/actions, o)
    expr1 : E -> Bool
}
\end{verbatim}
and we use it in a new subset of \texttt{E} as follows:
\begin{verbatim}
sig S6 extends E {} {
    this.(Functions.expr1) = True
}
\end{verbatim}

We make no other claims about \texttt{Functions.expr1}, and as a
result \texttt{S6} represents an arbitrary subset of \texttt{E}.

% arch-tag: 931ea1c1-9ebf-4e94-89e7-06ac1ad3856f

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
