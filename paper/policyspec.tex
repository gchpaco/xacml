\section{Policy Specifications}
\label{sec:policy-spec}

XACML is an OASIS standard for specifying access policies; it is
written in XML.  The language comprises three classes of
objects---individual rules, collections of rules called policies, and
collections of policies called policy sets.  An XACML Policy
Enforcement Point, the gateway that determines whether an action is
permitted or not, takes \emph{access requests}, which are specially
formatted XML documents that define a set of data that we call the
\emph{environment}.  Policy Enforcement Points yield one of four
results: Permit, meaning that the access request is permitted; Deny,
meaning that the access request will not be permitted; Not Applicable,
meaning that this particular policy says nothing about the request;
and Indeterminate, which means that something unexpected came up and
the policy has failed.  Which result is yielded depends on what result
the policy dictates, given the environment defined in the access
request.

XACML rules are the most basic object, and have a goal effect---either
Permit or Deny---a domain of applicability, and conditions under which
they can yield Indeterminate and fail.  The domain of applicability is
realized in a series of predicates about the environmental data that
must all be satisfied for the rule to yield its goal effect; the error
conditions are embedded in the domain predicates, but can be separated
out into a set of predicates all their own.  Policies combine
individual rules and also have a domain of applicability; policy sets
combine individual policies with a domain of applicability.

XACML predicates comprise one of a number of primitive functions, with
mechanisms for extension; we do not consider any extensions.  These
functions include simple equality, set inclusion, ordering within
numeric types, and also more complex functions such as XPath matching
and X500 name matching.

\begin{figure}[t]
\centering
\begin{scriptsize}
 \input{trimmedexample.xacml}
\end{scriptsize}
\caption{A simple XACML policy}
\label{fig:example}
\end{figure}

Let us consider a simple example policy. 
The policy states that to be able to vote a person must be at least 18 years old
and a person who has voted already cannot vote. 
Our environment, the set of
information we are interested in, consists of the age of the person in
question and whether they have voted already.  We can represent this
as a Cartesian product of XML Schema~\cite{xmlschema} basic types,
as follows:
\begin{equation*}
  E = \mathcal{P} (\mtt{xsd:int}) \times \mathcal{P} (\mtt{xsd:boolean})
  \times \mathcal{P} (\mtt{xsd:string})
  \label{eqn:env}
\end{equation*}
The first component of the environment $E$ is the age of the
person, the second component is whether or not they have voted
already, and the third component is the action they are attempting
(perhaps voting, but perhaps something else).  We use power sets here
because in XACML all attributes describe sets of values, never
singletons.

The XACML policy for this
example is shown in Figure \ref{fig:example}.
We will explain the semantics of this policy
using a simple mathematical notation below. 
The goal for our policy is that if a person is doing something other than
voting, we do not really care what happens, and we require that there
be only one age and one voting record presented.  To do this we can
divide $E$ into four sets, $E_a$, $E_v$, $E_p$ and $E_d$ as follows
(note that the notation $\exists ! \, x \, P$ asserts that there is a
unique $x$ that satisfies a condition $P$):
\begin{eqnarray*}
  E_a & = & \{ \langle a, v, o \rangle \in E : \exists ! \, a_0 \in a 
  \wedge \exists ! \, v_0 \in v \} \\
  E_v & = & \{ \langle a, v, o \rangle \in E_a : \exists x \in o \; 
  x = \texttt{vote} \} \\
  E_p & = & \{ \langle \{a_0\}, \{v_0\}, o \rangle \in E_v : a_0 \geq 18 
  \wedge \neg v_0 \} \\
  E_d & = & E_v - E_p 
   =  \{ \langle \{a_0\}, \{v_0\}, o \rangle \in E_v : a_0 < 18 \vee v_0 \}
\end{eqnarray*}
Here, $E_a$ is the set of all environments whose inputs are not
erroneous, $E_v$ is the set of all environments where voting is
attempted, $E_p$ is the set of all environments where the person can
vote (their attempt to vote is \emph{permitted}), and $E_d$ is the set
of all environments where the person cannot vote (their attempt to
vote is \emph{denied}).  
In the following
section we will define a concise formal model for XACML policies.

\subsection{Formal Model}
\label{sec:formal-model}

Let $R = \{ \Permit, \Deny, \NotApplicable, \Indeterminate \}$ be the set
of valid results.  Now, we can define the set of valid policies $P$ as
follows (semantics will be defined later):
\begin{eqnarray*}
  \Permit & \in & P \\
  \Deny & \in & P \\
  \forall p \in P \;\, \forall S \subseteq E \; \Scope (p, S) & \in & P \\
  \forall p \in P \;\, \forall S \subseteq E \; \Err (p, S) & \in & P \\
  \forall p, q \in P \; p \oplus q & \in & P \\
  \forall p, q \in P \; p \ominus q & \in & P \\
  \forall p, q \in P \; p \otimes q & \in & P \\
  \forall p, q \in P \; p \oslash q & \in & P
\end{eqnarray*}
Informally, we regard \Permit{} and \Deny{} as symbols whose semantics
ignore the environment, always yielding \Permit{} or \Deny{},
respectively.  Along these same lines, \Scope{} and \Err{} attach
conditions to policies:
\begin{itemize}
\item $\Scope (p, S)$ modifies policy $p$ to yield $p$'s
answer if the current environment is in $S$, or \NotApplicable{}
otherwise.
\item $\Err (p, S)$ yields \Indeterminate{} if 
the current environment is in $S$ or $p$'s answer otherwise.  
\end{itemize}
The other four
symbols ($\oplus, \ominus, \otimes, \oslash$) are combinators, that
combine two policies in various ways:
\begin{itemize}
\item {\bf Permit-overrides:} $p \oplus q$ always yields
\Permit{} if either $p$ or $q$ yield \Permit{}.
\item  {\bf Deny-overrides:} $p \ominus q$ always
yields \Deny{} if either $p$ or $q$ yield \Deny{}.
\item  {\bf Only-one-applicable:} $p \otimes q$ requires that
one of $p$ or $q$ yield \NotApplicable{} and then yields the other
half's answer.
\item {\bf First-applicable:} $p \oslash q$ yields $p$'s answer unless that is
\NotApplicable{}, in which case it yields $q$'s answer.
\end{itemize}

More formally, we define a function $\eff : E \times P \rightarrow R$
that, given an environment and a policy produces a result.  We define
this function in Figure~\ref{fig:semantics} so that it corresponds to
our intuition about the desired properties, as described above.

\begin{figure}[t]
\centering
\begin{footnotesize}
\begin{eqnarray*}
  \eff & : & E \times P \rightarrow R \\
  \eff (e, \Permit) & = & \Permit \\
  \eff (e, \Deny) & = & \Deny \\
  \eff (e, \Scope (p, S)) & = & \left\{\begin{array}{ll}
  \eff (e, p) & \text{if $e \in S$} \\
  \NotApplicable & \text{otherwise}
  \end{array}\right. \\
  \eff (e, \Err (p, S)) & = & \left\{\begin{array}{ll}
  \Indeterminate & \text{if $e \in S$} \\
  \eff (e, p) & \text{otherwise}
  \end{array}\right. \\
  \eff (e, p \oplus q) & = & \left\{\begin{array}{ll}
  \Permit & \text{if $\eff(e, p) = \Permit$} \\
  & \text{$\quad \vee \eff(e, q) = \Permit$} \\
  \Indeterminate & \text{if } (\eff(e, p) = \Indeterminate \\
  & \quad \wedge \eff(e, q) \neq \Permit) \\
  &  \vee (\eff(e, q) = \Indeterminate \\
  & \quad \wedge \eff(e, p) \neq \Permit) \\
  \Deny & \text{if } (\eff(e, p) = \Deny \\
  & \quad \wedge \eff(e, q) \neq \Permit \\
  & \quad \wedge \eff(e, q) \neq \Indeterminate) \\
  & \vee (\eff(e, q) = \Deny \\
  & \quad \wedge \eff(e, p) \neq \Permit \\
  & \quad \wedge \eff(e, p) \neq \Indeterminate) \\
  \NotApplicable & \text{otherwise}
  \end{array}\right. \\
  \eff (e, p \ominus q) & = & \left\{\begin{array}{ll}
  \Deny & \text{if $\eff(e, p) = \Deny$} \\
  & \text{$\quad \vee (\eff(e, q) = \Deny$} \\
  \Indeterminate & \text{if } (\eff(e, p) = \Indeterminate \\
  & \quad \wedge \eff(e, q) \neq \Deny) \\
  & \vee (\eff(e, q) = \Indeterminate \\
  & \quad \wedge \eff(e, p) \neq \Deny) \\
  \Permit & \text{if } (\eff(e, p) = \Permit \\
  & \quad \wedge \eff(e, q) \neq \Deny \\
  & \quad \wedge \eff(e, q) \neq \Indeterminate) \\
  & \vee (\eff(e, q) = \Permit \\
  & \quad \wedge \eff(e, p) \neq \Deny \\
  & \quad \wedge \eff(e, p)\neq \Indeterminate) \\
  \NotApplicable & \text{otherwise}
  \end{array}\right. \\
  \eff (e, p \otimes q) & = & \left\{\begin{array}{ll}
  \eff (e, p) & \text{if $\eff(e, q) = \NotApplicable$} \\
  \eff (e, q) & \text{if $\eff(e, p) = \NotApplicable$} \\
  \Indeterminate & \text{otherwise}
  \end{array}\right. \\
  \eff (e, p \oslash q) & = & \left\{\begin{array}{ll}
  \eff (e, p) & \text{if $\eff(e, p) \neq \NotApplicable$} \\
  \eff (e, q) & \text{otherwise}
  \end{array}\right.
\end{eqnarray*}
\end{footnotesize}
\caption{Semantics of policies}
\label{fig:semantics}
\end{figure}

Using this notation, we can now model our example as follows:
\begin{eqnarray}
  S_0 & = & \{ \langle a, v, o \rangle \in E : \forall x \in a \; x < 18 \} 
  \label{eq:s0} \\
  S_1 & = & \{ \langle a, v, o \rangle \in E : \forall x \in v \; x \}
  \label{eq:s1} \\
  S_2 & = & \{ \langle a, v, o \rangle \in E : 
  \exists x \in o \; x = \mtt{vote} \} \label{eq:s2} \\
  S_3 & = & \{ \langle a, v, o \rangle \in E : \neg \exists ! \, a_0 \in a \} 
  \label{eq:s3} \\
  S_4 & = & \{ \langle a, v, o \rangle \in E : \neg \exists ! \, v_0 \in v \}
  \label{eq:s4} \\
  r_1 & = & \Err (\Scope (\Deny, S_0), S_3) \label{eq:r1} \\
  r_2 & = & \Err (\Scope (\Deny, S_1), S_4) \label{eq:r2} \\
  p & = & \Scope (r_1 \ominus r_2 \ominus \Permit, S_2) \label{eq:p}
\end{eqnarray}
Here, $S_0$ is the set of environments that fail the age requirement,
$S_1$ is the set of environments that fail the voting requirement,
$S_2$ is the set of environments where someone's trying to vote, etc.

\subsection{Policy Transformations}
\label{sec:transformations}

\begin{figure}[t]
\centering
\begin{footnotesize}
\begin{eqnarray*}
  f & : & P   \rightarrow  P \nonumber \\
  f (\Scope (\Scope (X, S), R))  & = & f (\Scope (X, R \cap S)) 
  \nonumber \\
  f (\Scope (\Err (X, S), R)) & = & f (\Err (\Scope (X, R \setminus S), S \cap R)) 
  \nonumber \\
  f (\Scope (X \oplus Y, S)) & = & \Scope (f (X), S) \oplus \Scope (f (Y), S) 
  \nonumber \\
  f (\Scope (X \ominus Y, S)) & = & \Scope (f (X), S) \ominus \Scope (f (Y), S) 
  \nonumber \\
  f (\Scope (X \otimes Y, S)) & = & \Scope (f (X), S) \otimes \Scope (f (Y), S)) 
  \nonumber \\
  f (\Scope (X \oslash Y, S)) & = & \Scope (f (X), S) \oslash \Scope (f (Y), S) 
  \nonumber \\
  f (\Scope (P, S)) & = & \Scope (f (P), S) 
     \ \text{if no other rules apply} \nonumber \\
  f (\Err (\Err (X, S), R)) & = & f (\Err (X, R \cup S)) \nonumber \\
  f (\Err (\Scope (X, S), R)) & = & f (\Err (\Scope (X, S \setminus R), R)) 
     \ \text{if $S \cup R \neq \emptyset$} \nonumber \\
  f (\Err (X \oplus Y, S))  & = &  \Err (f (X), S) \oplus \Err (f (Y), S) \nonumber \\
  f (\Err (X \ominus Y, S)) & = &  \Err (f (X), S) \ominus \Err (f (Y), S) \nonumber \\
  f (\Err (X \otimes Y, S)) & = &  \Err (f (X), S) \otimes \Err (f (Y), S) \nonumber \\
  f (\Err (X \oslash Y, S)) & = &  \Err (f (X), S) \oslash \Err (f (Y), S) \nonumber \\
  f (\Err (P, S)) & = & \Err (f (P), S) 
     \  \text{if no other rules apply} \nonumber \\
  f (\Permit) & = & \Permit \nonumber \\
  f (\Deny) & = & \Deny \nonumber
\end{eqnarray*}
\end{footnotesize}
\caption{$\eff$-preserving transformations for reduction to normal form}
\label{fig:1streduction}
\end{figure}

We would like to perform analysis on this model, and it would be
easier to do this analysis if we could bring the model into a normal
form.  To do this, first we define equivalence:
\begin{equation*}
  P_1 \equiv P_2 \text{ iff } \forall e \in E \; \eff (e, P_1) = \eff (e, P_2)
\end{equation*}
We call a function $f$ that takes a policy and returns another
policy an \emph{$\eff$-preserving transformation} if $\forall p \in P
\; f (p) \equiv p$.

For any given policy, we want to regard the subset of $E$ that will
give a \Permit{} result, the subset of $E$ that will give a \Deny{}
result, and the subset of $E$ that will give an \Indeterminate{} result
independently.  We define the shorthand $\langle S, R, T \rangle$,
where $S$, $R$ and $T$ are pairwise disjoint, as follows:
\begin{equation*}
  \langle S, R, T \rangle = \Err (\Scope (\Permit, S) \otimes \Scope (\Deny, R), T)
\end{equation*}
Hence, $\langle S, R, T \rangle$ is simply a policy
that yields \Permit{} for any environment in $S$,
\Deny{} for any environment in $R$,
\Indeterminate{} for any environment in $T$,
and \NotApplicable{} for any remaining environment.
We call this \emph{triple notation} and refer to individual nodes
$\langle S, R, T \rangle$ as \emph{triples}.

Now that we have a framework for transforming policies, we would like
to transform an entire policy with $\Scope$, $\Err$ and combinators alike
into a single triple.  We know that for any policy $P$ a triple $P_T$
that is equivalent to it exists: the triple is just 
\begin{eqnarray*}
P_T & = & \langle \{
e \in E : \eff (e, P) = \Permit \}, \\
&& \;\, \{ e \in E : \eff (e, P) = \Deny \}, \\
&& \;\, \{ e \in E : \eff (e, P) = \Indeterminate \}\rangle.
\end{eqnarray*}
However,
this is not a constructive definition.  To transform the policies to
the triple form, we define two functions 
$f : P   \rightarrow  P$ and $g : P \rightarrow \langle S, R, T \rangle$, both
$\eff$-preserving transformations, such that $g (f(p))$ is a triple
for all $p$.  The $f$ function transforms the policy into an
equivalent one that is composed of triples joined by combinators.  The
$g$ function combines triples joined by combinators into a single
triple.  The two together generate the triple representation.  We
define $f$ in Figure~\ref{fig:1streduction}, and $g$ in
Figure~\ref{fig:triplereduction}.

As an example, applying $f$ to the policy $p$ defined in
Equation~\eqref{eq:p} leads to the following:
\begin{eqnarray*}
  p & = & \Scope (\Err (\Scope (\Deny, S_0), S_3) \\
  & & \qquad \ominus \, \Err (\Scope (\Deny, S_1), S_4) \\
  & & \qquad \ominus \, \Permit, S_2) \nonumber \\
  f(p)  & = & \Err (\Scope (\Deny, (S_2 \cap S_0) \setminus S_3), S_3 \cap S_2) \\
  & & \qquad \ominus \,
  \Err (\Scope (\Deny, (S_2 \cap S_1) \setminus S_4), S_4 \cap S_2) \\
  & & \qquad \ominus \, \Scope (\Permit, S_2)
\end{eqnarray*}
Note that the function $f$ pushes all $\Scope$ forms down to the leaves
of the policy tree, and all $\Err$ forms down to just above the leaves.

The $f$ function transforms a policy to a collection of expressions of
the form $\Err (\Scope (A, B), T)$ (where $A \in \{ \Permit, \Deny
\}$, $B, T \subseteq E$, and $B \cap T = \emptyset$) combined using
$\oplus, \ominus, \otimes$ and $\oslash$.  Since $\forall e \in E \,
\eff (e, X \otimes \Scope (Y, \emptyset)) = \eff (e, X)$, we can
further rewrite these expressions in the form $\Err (\Scope (\Permit,
S)$ $\otimes$ $\Scope (\Deny, R), T)$ combined with $\oplus, \ominus,
\otimes$ and $\oslash$ where $S = B$ and $R = \emptyset$ if $A =
\Permit$ and $S = \emptyset$ and $R = B$ if $A = \Deny$.  Since $S, R$
and $T$ are all pairwise disjoint this is exactly the required form
for our triple notation.  Hence, after applying the function $f$ we
have a set of subpolicies in our triple notation combined with
$\oplus, \ominus, \otimes$ and $\oslash$.  We define the function $g$
in Figure~\ref{fig:triplereduction}.  The transformations for function
$g$ all preserve the disjointness property, and using the function $g$
we can transform the policy generated by function $f$ to a single
triple $\langle S, R, T \rangle$ for some $S, R, T \subseteq E$.

\begin{figure*}[t]
\centering
\begin{footnotesize}
\begin{eqnarray*}
  g & : & P \rightarrow \langle S, R, T \rangle \\
  g (\langle S_1, R_1, T_1 \rangle \oplus \langle S_2, R_2, T_2 \rangle) & = & 
  \langle 
  S_1 \cup S_2, (R_1 \setminus (S_2 \cup T_2)) \cup (R_2 \setminus (S_1 \cup T_1)), 
  (T_1 \cup T_2) \setminus (S_1 \cup S_2)
  \rangle \\
  g (\langle S_1, R_1, T_1 \rangle \ominus \langle S_2, R_2, T_2 \rangle)
  & = & \langle (S_1 \setminus (R_2 \cup T_2)) \cup 
  (S_2 \setminus (R_1 \cup T_1)), 
  R_1 \cup R_2,
  (T_1 \cup T_2) \setminus (R_1 \cup R_2)
  \rangle
  \\
  g (\langle S_1, R_1, T_1 \rangle \otimes \langle S_2, R_2, T_2 \rangle)
  & = & \langle 
  (S_1 \cup S_2) \setminus ((S_1 \cap S_2) \cup T_1 \cup T_2), 
  (R_1 \cup R_2) \setminus ((R_1 \cap R_2) \cup T_1 \cup T_2), 
  T_1 \cup T_2 \cup (S_1 \cap S_2) \cup (R_1 \cap R_2)
  \rangle 
  \\
  g (\langle S_1, R_1, T_1 \rangle \oslash \langle S_2, R_2, T_2 \rangle)
  & = & \langle 
  S_1 \cup (S_2 \setminus (R_1 \cup T_1)),
  R_1 \cup (R_2 \setminus (S_1 \cup T_1)), 
  T_1 \cup (T_2 \setminus (S_1 \cup R_1))
  \rangle
  \\
  g (\langle S_1, R_1, T_1 \rangle) & = & \langle  S_1, R_1, T_1 \rangle 
  \\
  g (P_1 \oplus P_2) & = & g (g (P_1) \oplus g (P_2)) \quad 
  \text{if no other rules apply}  \\
  g (P_1 \ominus P_2) & = & g (g (P_1) \ominus g (P_2)) \quad 
  \text{if no other rules apply}  \\
  g (P_1 \otimes P_2) & = & g (g (P_1) \otimes g (P_2)) \quad 
  \text{if no other rules apply}  \\
  g (P_1 \oslash P_2) & = & g (g (P_1) \oslash g (P_2)) \quad
  \text{if no other rules apply} 
\end{eqnarray*}
\end{footnotesize}
\caption{$\eff$-preserving transformations for $\langle S, R, T \rangle$ 
  reduction}
\label{fig:triplereduction}
\end{figure*}

When we apply the function $g$ to our example we get the following:
\begin{eqnarray*}
  f(p) & = & \Err (\Scope (\Deny, (S_2 \cap S_0) \setminus S_3), S_3 \cap S_2) \\
  & & \ominus \, \Err (\Scope (\Deny, (S_2 \cap S_1) \setminus S_4), S_4 \cap S_2) \\
  & & \ominus \, \Scope (\Permit, S_2)
  \\
  & = & \langle \emptyset, S_2 \cap S_0 \setminus S_3, S_3 \cap S_2 \rangle \\
  & & \ominus \langle \emptyset, S_2 \cap S_1 \setminus S_4, S_4 \cap S_2 \rangle \\
  & & \ominus \langle S_2, \emptyset, \emptyset \rangle
  \\
  g(f(p))  & = & \langle S_2 \setminus (S_0 \cup S_1 \cup S_3 \cup S_4), \\
  & & ((S_0 \cup S_1) \setminus (S_3 \cup S_4)) \cap S_2, \\
  & &  (S_3 \cup S_4) \cap S_2 \rangle
\end{eqnarray*}

Now that we have our policy into a form that is convenient for
analysis, we can begin to prove things about it.

% arch-tag: 834f4d24-c6fd-4bef-9e73-89b1efa5ca0b

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
