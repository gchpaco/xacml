<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from t-y-scheme.tex by tex2page, v 2004-09-11
(running on MzScheme 209, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Teach Yourself Scheme in Fixnum Days
</title>
<link rel="stylesheet" type="text/css" href="t-y-scheme-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
<meta name=description content="A practical
introduction to the programming language Scheme">

<meta name=author content="Dorai Sitaram">

<link rev=made href="mailto:dorai @ ccs.neu.edu">
</head>
<body>
<div align=right class=navigation><i>[Go to <span><a href="t-y-scheme.html">first</a>, <a href="t-y-scheme-Z-H-3.html">previous</a></span><span>, <a href="t-y-scheme-Z-H-5.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="t-y-scheme-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="t-y-scheme-Z-H-25.html#node_index_start">index</a></span>]</i></div><p></p>
<a name="node_chap_2"></a>
<h1 class=chapter>
<div class=chapterheading><a href="t-y-scheme-Z-H-1.html#node_toc_node_chap_2">Chapter 2</a></div><br>
<a href="t-y-scheme-Z-H-1.html#node_toc_node_chap_2">Data types</a></h1>
<p><a name="node_idx_38"></a>
A <em>data type</em> is a collection of related values.
These collections
need not be disjoint, and they are often hierarchical.
Scheme has a rich set of data types: some are simple
(indivisible) data types and others are compound data types
made by combining other data types.</p>
<p>
<a name="node_idx_40"></a></p>
<p>
</p>
<a name="node_sec_2.1"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.1">2.1&nbsp;&nbsp;Simple data types</a></h2>
<p>The simple data types of Scheme include booleans, numbers,
characters, and symbols.</p>
<p>
<a name="node_idx_42"></a></p>
<p>
</p>
<a name="node_sec_2.1.1"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.1.1">2.1.1&nbsp;&nbsp;Booleans</a></h3>
<p></p>
<p>
<a name="node_idx_44"></a>
<a name="node_idx_46"></a>
<a name="node_idx_48"></a>
<a name="node_idx_50"></a>
<a name="node_idx_52"></a>
Scheme's booleans are <code class=scheme><span class=selfeval>#t</span></code> for true and <code class=scheme><span class=selfeval>#f</span></code> for false.
Scheme has a predicate procedure called <code class=scheme><span class=variable>boolean?</span></code> that
checks if its argument is boolean.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>boolean?</span> <span class=selfeval>#t</span>)              <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>boolean?</span> <span class=selfeval>&quot;Hello, World!&quot;</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
<a name="node_idx_54"></a></p>
<p>
The procedure <code class=scheme><span class=variable>not</span></code> negates its argument, considered as a
boolean.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>not</span> <span class=selfeval>#f</span>)              <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>not</span> <span class=selfeval>#t</span>)              <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>not</span> <span class=selfeval>&quot;Hello, World!&quot;</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
The last expression illustrates a Scheme convenience:
In a context that requires a boolean, Scheme will treat
any value that is not <code class=scheme><span class=selfeval>#f</span></code> as a true value.</p>
<p>
<a name="node_idx_56"></a></p>
<p>
</p>
<a name="node_sec_2.1.2"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.1.2">2.1.2&nbsp;&nbsp;Numbers</a></h3>
<p>Scheme numbers can be integers (eg, <code class=scheme><span class=selfeval>42</span></code>), rationals
(<code class=scheme><span class=selfeval>22/7</span></code>), reals (<code class=scheme><span class=selfeval>3.1416</span></code>), or complex (<code class=scheme><span class=selfeval>2+3i</span></code>).  An
integer is a rational is a real is a complex number is a
number.  Predicates exist for testing the various kinds of
numberness:</p>
<p>
<a name="node_idx_58"></a>
<a name="node_idx_60"></a>
<a name="node_idx_62"></a>
<a name="node_idx_64"></a>
<a name="node_idx_66"></a></p>
<p>
</p>
<pre class=scheme>(<span class=variable>number?</span> <span class=selfeval>42</span>)       <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>number?</span> <span class=selfeval>#t</span>)       <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>complex?</span> <span class=selfeval>2+3i</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>real?</span> <span class=selfeval>2+3i</span>)       <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>real?</span> <span class=selfeval>3.1416</span>)     <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>real?</span> <span class=selfeval>22/7</span>)       <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>real?</span> <span class=selfeval>42</span>)         <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>rational?</span> <span class=selfeval>2+3i</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>rational?</span> <span class=selfeval>3.1416</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>rational?</span> <span class=selfeval>22/7</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>integer?</span> <span class=selfeval>22/7</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>integer?</span> <span class=selfeval>42</span>)      <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
<a name="node_idx_68"></a>
<a name="node_idx_70"></a>
<a name="node_idx_72"></a>
<a name="node_idx_74"></a></p>
<p>
Scheme integers need not be specified in decimal (base 10)
format.  They can be specified in binary by prefixing the
numeral with <code class=scheme><span class=selfeval>#b</span></code>.  Thus <code class=scheme><span class=selfeval>#b1100</span></code> is the number twelve.
The octal prefix is <code class=scheme><span class=selfeval>#o</span></code> and the hex prefix is
<code class=scheme><span class=selfeval>#x</span></code>.  (The optional decimal prefix is <code class=scheme><span class=selfeval>#d</span></code>.)</p>
<p>
<a name="node_idx_76"></a></p>
<p>
Numbers can tested for equality using the general-purpose
equality predicate <code class=scheme><span class=variable>eqv?</span></code>.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>eqv?</span> <span class=selfeval>42</span> <span class=selfeval>42</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>eqv?</span> <span class=selfeval>42</span> <span class=selfeval>#f</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>eqv?</span> <span class=selfeval>42</span> <span class=selfeval>42.0</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
<a name="node_idx_78"></a></p>
<p>
However, if you know that the arguments to be compared are
numbers, the special number-equality predicate <code class=scheme><span class=variable>=</span></code> is more
apt.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>=</span> <span class=selfeval>42</span> <span class=selfeval>42</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>=</span> <span class=selfeval>42</span> <span class=selfeval>#f</span>)   <font color="red"><tt><strong><i>--&gt;ERROR!!!</i></strong></tt></font>
(<span class=variable>=</span> <span class=selfeval>42</span> <span class=selfeval>42.0</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
<a name="node_idx_80"></a>
<a name="node_idx_82"></a>
<a name="node_idx_84"></a>
<a name="node_idx_86"></a></p>
<p>
Other number comparisons allowed are
<code class=scheme><span class=variable>&lt;</span></code>, <code class=scheme><span class=variable>&lt;=</span></code>, <code class=scheme><span class=variable>&gt;</span></code>, <code class=scheme><span class=variable>&gt;=</span></code>.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>&lt;</span> <span class=selfeval>3</span> <span class=selfeval>2</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>&gt;=</span> <span class=selfeval>4.5</span> <span class=selfeval>3</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
<a name="node_idx_88"></a>
<a name="node_idx_90"></a>
<a name="node_idx_92"></a>
<a name="node_idx_94"></a>
<a name="node_idx_96"></a></p>
<p>
Arithmetic procedures <code class=scheme><span class=variable>+</span></code>, <code class=scheme><span class=variable>-</span></code>, <code class=scheme><span class=variable>*</span></code>, <code class=scheme><span class=variable>/</span></code>, <code class=scheme><span class=variable>expt</span></code> have the
expected behavior:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>+</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>6</span>
(<span class=variable>-</span> <span class=selfeval>5.3</span> <span class=selfeval>2</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>3.3</span>
(<span class=variable>-</span> <span class=selfeval>5</span> <span class=selfeval>2</span> <span class=selfeval>1</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>2</span>
(<span class=variable>*</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span>)    <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>6</span>
(<span class=variable>/</span> <span class=selfeval>6</span> <span class=selfeval>3</span>)      <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>2</span>
(<span class=variable>/</span> <span class=selfeval>22</span> <span class=selfeval>7</span>)     <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>22/7</span>
(<span class=variable>expt</span> <span class=selfeval>2</span> <span class=selfeval>3</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>8</span>
(<span class=variable>expt</span> <span class=selfeval>4</span> <span class=selfeval>1/2</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>2.0</span>
</pre><p></p>
<p>
For a single argument, <code class=scheme><span class=variable>-</span></code> and <code class=scheme><span class=variable>/</span></code> return the negation
and the reciprocal respectively:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>-</span> <span class=selfeval>4</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>-4</span>
(<span class=variable>/</span> <span class=selfeval>4</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>1/4</span>
</pre><p></p>
<p>
<a name="node_idx_98"></a>
<a name="node_idx_100"></a></p>
<p>
The procedures <code class=scheme><span class=variable>max</span></code> and <code class=scheme><span class=variable>min</span></code> return the maximum and
minimum respectively of the number arguments supplied to
them.  Any number of arguments can be so supplied.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>max</span> <span class=selfeval>1</span> <span class=selfeval>3</span> <span class=selfeval>4</span> <span class=selfeval>2</span> <span class=selfeval>3</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>4</span>
(<span class=variable>min</span> <span class=selfeval>1</span> <span class=selfeval>3</span> <span class=selfeval>4</span> <span class=selfeval>2</span> <span class=selfeval>3</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>1</span>
</pre><p></p>
<p>
<a name="node_idx_102"></a></p>
<p>
The procedure <code class=scheme><span class=variable>abs</span></code> returns the absolute value of
its argument.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>abs</span>  <span class=selfeval>3</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>3</span>
(<span class=variable>abs</span> <span class=selfeval>-4</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>4</span>
</pre><p></p>
<p>
<a name="node_idx_104"></a>
<a name="node_idx_106"></a>
<a name="node_idx_108"></a></p>
<p>
This is just the tip of the iceberg.  Scheme
provides a large and comprehensive suite of arithmetic
and trigonometric procedures.  For instance, <code class=scheme><span class=variable>atan</span></code>,
<code class=scheme><span class=variable>exp</span></code>, and <code class=scheme><span class=variable>sqrt</span></code> respectively return the
arctangent, natural antilogarithm, and 
square root of their argument.  Consult
R5RS [<a href="t-y-scheme-Z-H-24.html#node_bib_23">23</a>] for more details.</p>
<p>
<a name="node_idx_110"></a></p>
<p>
</p>
<a name="node_sec_2.1.3"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.1.3">2.1.3&nbsp;&nbsp;Characters</a></h3>
<p><a name="node_idx_112"></a>
Scheme character data are represented by prefixing the
character with <code class=verbatim>#\</code>.  Thus, <code class=scheme><span class=selfeval>#\c</span></code> is the character
<code class=verbatim>c</code>.  Some non-graphic characters have more descriptive
names, eg, <code class=scheme><span class=selfeval>#\newline</span></code>, <code class=scheme><span class=selfeval>#\tab</span></code>.  The character for
space can be written <code class=scheme><span class=selfeval>#\ </span></code>&nbsp;,  or more readably, <code class=scheme><span class=selfeval>#\space</span></code>.</p>
<p>
<a name="node_idx_114"></a></p>
<p>
The character predicate is <code class=scheme><span class=variable>char?</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>char?</span> <span class=selfeval>#\c</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>char?</span> <span class=selfeval>1</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>char?</span> <span class=selfeval>#\;</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
Note that a semicolon character datum does not trigger
a comment.</p>
<p>
<a name="node_idx_116"></a>
<a name="node_idx_118"></a>
<a name="node_idx_120"></a>
<a name="node_idx_122"></a>
<a name="node_idx_124"></a></p>
<p>
The character data type has its set of comparison
predicates: <code class=scheme><span class=variable>char=?</span></code>, <code class=scheme><span class=variable>char&lt;?</span></code>, <code class=scheme><span class=variable>char&lt;=?</span></code>, <code class=scheme><span class=variable>char&gt;?</span></code>,
<code class=scheme><span class=variable>char&gt;=?</span></code>.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>char=?</span> <span class=selfeval>#\a</span> <span class=selfeval>#\a</span>)  <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>char&lt;?</span> <span class=selfeval>#\a</span> <span class=selfeval>#\b</span>)  <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>char&gt;=?</span> <span class=selfeval>#\a</span> <span class=selfeval>#\b</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
<a name="node_idx_126"></a>
<a name="node_idx_128"></a>
<a name="node_idx_130"></a>
<a name="node_idx_132"></a>
<a name="node_idx_134"></a></p>
<p>
To make the comparisons case-insensitive, use <code class=scheme><span class=variable>char-ci</span></code>
instead of <code class=scheme><span class=variable>char</span></code> in the procedure name:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>char-ci=?</span> <span class=selfeval>#\a</span> <span class=selfeval>#\A</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>char-ci&lt;?</span> <span class=selfeval>#\a</span> <span class=selfeval>#\B</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
<a name="node_idx_136"></a>
<a name="node_idx_138"></a></p>
<p>
The case conversion procedures are <code class=scheme><span class=variable>char-downcase</span></code> and
<code class=scheme><span class=variable>char-upcase</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>char-downcase</span> <span class=selfeval>#\A</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#\a</span>
(<span class=variable>char-upcase</span> <span class=selfeval>#\a</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#\A</span>
</pre><p></p>
<p>
<a name="node_idx_140"></a></p>
<p>
</p>
<a name="node_sec_2.1.4"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.1.4">2.1.4&nbsp;&nbsp;Symbols</a></h3>
<p><a name="node_idx_142"></a>
The simple data types we saw above are <em>self-evaluating</em>.  Ie, if you typed any object from these
data types to the listener, the evaluated result returned by
the listener will be the same as what you typed in.</p>
<p>
</p>
<pre class=scheme><span class=selfeval>#t</span>  <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
<span class=selfeval>42</span>  <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>42</span>
<span class=selfeval>#\c</span> <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#\c</span>
</pre><p></p>
<p>
<a name="node_idx_144"></a>
<a name="node_idx_146"></a></p>
<p>
Symbols don't behave the same way.  This is because symbols
are used by Scheme programs as <em>identifiers</em> for <em>variables</em>, and thus will evaluate to the value that the
variable holds.  Nevertheless, symbols are a simple data
type, and symbols are legitimate values that Scheme can
traffic in, along with characters, numbers, and the rest.</p>
<p>
<a name="node_idx_148"></a></p>
<p>
To specify a symbol without making Scheme think it is a
variable, you should <em>quote</em> the symbol:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>quote</span> <span class=variable>xyz</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=variable>xyz</span>
</pre><p></p>
<p>
<a name="node_idx_150"></a></p>
<p>
Since this type of quoting is very common in Scheme, a
convenient abbreviation is provided.  The expression</p>
<p>
</p>
<pre class=scheme><span class=keyword>'</span><span class=variable>E</span>
</pre><p></p>
<p>
will be treated by Scheme as equivalent to</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>quote</span> <span class=variable>E</span>)
</pre><p></p>
<p>
<a name="node_idx_152"></a></p>
<p>
Scheme symbols are named by a sequence of characters.  About
the only limitation on a symbol's name is that it shouldn't
be mistakable for some other data, eg, characters or booleans
or numbers or compound data.  Thus, <code class=scheme><span class=variable>this-is-a-symbol</span></code>,
<code class=scheme><span class=variable>i18n</span></code>,
<code class=scheme><span class=variable>&lt;=&gt;</span></code>, and <code class=scheme><span class=variable>$!#*</span></code> are all symbols; <code class=scheme><span class=selfeval>16</span></code>, <code class=scheme><span class=selfeval>-i</span></code> (a
complex number!), <code class=scheme><span class=selfeval>#t</span></code>, <code class=scheme><span class=selfeval>&quot;this-is-a-string&quot;</span></code>, and
<code class=scheme>(<span class=variable>barf</span>)</code> (a list) are not.    The predicate for
checking symbolness is called <code class=scheme><span class=variable>symbol?</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>symbol?</span> <span class=keyword>'</span><span class=variable>xyz</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>symbol?</span> <span class=selfeval>42</span>)   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
<a name="node_idx_154"></a></p>
<p>
Scheme symbols are normally case-insensitive.  Thus the
symbols
<code class=scheme><span class=variable>Calorie</span></code> and <code class=scheme><span class=variable>calorie</span></code> are identical:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>eqv?</span> <span class=keyword>'</span><span class=variable>Calorie</span> <span class=keyword>'</span><span class=variable>calorie</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
<a name="node_idx_156"></a>
<a name="node_idx_158"></a></p>
<p>
We can use the symbol <code class=scheme><span class=variable>xyz</span></code> as a global variable by using
the form <code class=scheme><span class=keyword>define</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>xyz</span> <span class=selfeval>9</span>)
</pre><p></p>
<p>
This says the variable <code class=scheme><span class=variable>xyz</span></code> holds the value <code class=scheme><span class=selfeval>9</span></code>.  If we
feed <code class=scheme><span class=variable>xyz</span></code> to the listener, the result will be the value
held by <code class=scheme><span class=variable>xyz</span></code>:</p>
<p>
</p>
<pre class=scheme><span class=variable>xyz</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>9</span>
</pre><p></p>
<p>
<a name="node_idx_160"></a>
We can use the form <code class=scheme><span class=keyword>set!</span></code> to <em>change</em> the value held by a
variable:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>set!</span> <span class=variable>xyz</span> <span class=selfeval>#\c</span>)
</pre><p></p>
<p>
Now</p>
<p>
</p>
<pre class=scheme><span class=variable>xyz</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#\c</span>
</pre><p></p>
<p>
<a name="node_idx_162"></a></p>
<p>
</p>
<a name="node_sec_2.2"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.2">2.2&nbsp;&nbsp;Compound data types</a></h2>
<p>Compound data types are built by combining values from
other data types in structured ways.</p>
<p>
<a name="node_idx_164"></a></p>
<p>
</p>
<a name="node_sec_2.2.1"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.2.1">2.2.1&nbsp;&nbsp;Strings</a></h3>
<p>Strings are sequences of characters (not to be confused with
symbols, which are simple data that have a sequence of
characters as their name).  You can specify strings by
enclosing the constituent characters in double-quotes.
Strings evaluate to themselves.</p>
<p>
</p>
<pre class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;Hello, World!&quot;</span>
</pre><p></p>
<p>
<a name="node_idx_166"></a></p>
<p>
The procedure <code class=scheme><span class=variable>string</span></code> takes a bunch of characters and
returns the string made from them:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>string</span> <span class=selfeval>#\h</span> <span class=selfeval>#\e</span> <span class=selfeval>#\l</span> <span class=selfeval>#\l</span> <span class=selfeval>#\o</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;hello&quot;</span>
</pre><p></p>
<p>
Let us now define a global variable <code class=scheme><span class=variable>greeting</span></code>.  </p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>greeting</span> <span class=selfeval>&quot;Hello; Hello!&quot;</span>)
</pre><p></p>
<p>
Note that a semicolon inside a string datum does not
trigger a comment.</p>
<p>
<a name="node_idx_168"></a></p>
<p>
The characters in a given string can be individually
accessed and modified.  The procedure <code class=scheme><span class=variable>string-ref</span></code> takes a
string and a (0-based) index, and returns the character at
that index:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>string-ref</span> <span class=variable>greeting</span> <span class=selfeval>0</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#\H</span>
</pre><p></p>
<p>
<a name="node_idx_170"></a></p>
<p>
New strings can be created by appending other strings:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>string-append</span> <span class=selfeval>&quot;E &quot;</span>
               <span class=selfeval>&quot;Pluribus &quot;</span>
               <span class=selfeval>&quot;Unum&quot;</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;E Pluribus Unum&quot;</span>
</pre><p></p>
<p>
<a name="node_idx_172"></a></p>
<p>
You can make a string of a specified length, and fill it
with the desired characters later.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>a-3-char-long-string</span> (<span class=variable>make-string</span> <span class=selfeval>3</span>))
</pre><p></p>
<p>
<a name="node_idx_174"></a></p>
<p>
The predicate for checking stringness is <code class=scheme><span class=variable>string?</span></code>.</p>
<p>
<a name="node_idx_176"></a></p>
<p>
Strings obtained as a result of calls to <code class=scheme><span class=variable>string</span></code>,
<code class=scheme><span class=variable>make-string</span></code>, and <code class=scheme><span class=variable>string-append</span></code> are mutable.
The procedure <code class=scheme><span class=variable>string-set!</span></code> replaces the
character at a given index:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>hello</span> (<span class=variable>string</span> <span class=selfeval>#\H</span> <span class=selfeval>#\e</span> <span class=selfeval>#\l</span> <span class=selfeval>#\l</span> <span class=selfeval>#\o</span>)) 
<span class=variable>hello</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;Hello&quot;</span>

(<span class=variable>string-set!</span> <span class=variable>hello</span> <span class=selfeval>1</span> <span class=selfeval>#\a</span>)
<span class=variable>hello</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;Hallo&quot;</span>
</pre><p>
<a name="node_idx_178"></a></p>
<p>
</p>
<a name="node_sec_2.2.2"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.2.2">2.2.2&nbsp;&nbsp;Vectors</a></h3>
<p>Vectors are sequences like strings, but their elements can
be anything, not just characters.  Indeed, the elements can
be vectors themselves, which is a good way to generate
multidimensional vectors.</p>
<p>
<a name="node_idx_180"></a></p>
<p>
Here's a way to create a vector of the first five integers:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>vector</span> <span class=selfeval>0</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#</span>(<span class=selfeval>0</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
</pre><p></p>
<p>
Note Scheme's representation of a vector value: a <code class=verbatim>#</code>
character followed by the vector's contents enclosed in
parentheses.</p>
<p>
<a name="node_idx_182"></a></p>
<p>
In analogy with <code class=scheme><span class=variable>make-string</span></code>, the procedure
<code class=scheme><span class=variable>make-vector</span></code> makes a vector of a specific length:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>v</span> (<span class=variable>make-vector</span> <span class=selfeval>5</span>))
</pre><p></p>
<p>
The procedures <code class=scheme><span class=variable>vector-ref</span></code> and <code class=scheme><span class=variable>vector-set!</span></code> access and
modify vector elements.
The predicate for checking if something is a vector is <code class=scheme><span class=variable>vector?</span></code>.</p>
<p>
<a name="node_idx_184"></a>
<a name="node_idx_186"></a>
<a name="node_idx_188"></a>
<a name="node_idx_190"></a>
<a name="node_idx_192"></a></p>
<p>
</p>
<a name="node_sec_2.2.3"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.2.3">2.2.3&nbsp;&nbsp;Dotted pairs and lists</a></h3>
<p>A <em>dotted pair</em> is a compound value made by combining
any two arbitrary values into an ordered couple.  The
first element is called the <em>car</em>, the second
element is called the <em>cdr</em>, and the combining
procedure is <code class=scheme><span class=variable>cons</span></code>.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>cons</span> <span class=selfeval>1</span> <span class=selfeval>#t</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>1</span> . <span class=selfeval>#t</span>)
</pre><p></p>
<p>
Dotted pairs are not self-evaluating, and so to specify
them directly as data (ie, without producing them via
a <code class=scheme><span class=variable>cons</span></code>-call), one must explicitly quote them:</p>
<p>
</p>
<pre class=scheme><span class=keyword>'</span>(<span class=selfeval>1</span> . <span class=selfeval>#t</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>1</span> . <span class=selfeval>#t</span>)

(<span class=selfeval>1</span> . <span class=selfeval>#t</span>)  <font color="red"><tt><strong><i>--&gt;ERROR!!!</i></strong></tt></font>
</pre><p></p>
<p>
The accessor procedures are <code class=scheme><span class=variable>car</span></code> and <code class=scheme><span class=variable>cdr</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>x</span> (<span class=variable>cons</span> <span class=selfeval>1</span> <span class=selfeval>#t</span>))

(<span class=variable>car</span> <span class=variable>x</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>1</span>

(<span class=variable>cdr</span> <span class=variable>x</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
</pre><p></p>
<p>
<a name="node_idx_194"></a>
<a name="node_idx_196"></a></p>
<p>
The elements of a dotted pair can be replaced by the
mutator procedures <code class=scheme><span class=variable>set-car!</span></code> and <code class=scheme><span class=variable>set-cdr!</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>set-car!</span> <span class=variable>x</span> <span class=selfeval>2</span>)

(<span class=variable>set-cdr!</span> <span class=variable>x</span> <span class=selfeval>#f</span>)

<span class=variable>x</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>2</span> . <span class=selfeval>#f</span>)
</pre><p></p>
<p>
Dotted pairs can contain other dotted pairs.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>y</span> (<span class=variable>cons</span> (<span class=variable>cons</span> <span class=selfeval>1</span> <span class=selfeval>2</span>) <span class=selfeval>3</span>))

<span class=variable>y</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  ((<span class=selfeval>1</span> . <span class=selfeval>2</span>) . <span class=selfeval>3</span>)
</pre><p></p>
<p>
The <code class=scheme><span class=variable>car</span></code> of the <code class=scheme><span class=variable>car</span></code> of this list is <code class=scheme><span class=selfeval>1</span></code>.
The <code class=scheme><span class=variable>cdr</span></code> of the <code class=scheme><span class=variable>car</span></code> of this list is <code class=scheme><span class=selfeval>2</span></code>.
Ie,</p>
<p>
</p>
<pre class=scheme>(<span class=variable>car</span> (<span class=variable>car</span> <span class=variable>y</span>))
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>1</span>

(<span class=variable>cdr</span> (<span class=variable>car</span> <span class=variable>y</span>))
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>2</span>
</pre><p></p>
<p>
<a name="node_idx_198"></a></p>
<p>
Scheme provides procedure abbreviations for cascaded
compositions of the <code class=scheme><span class=variable>car</span></code> and <code class=scheme><span class=variable>cdr</span></code> procedures.
Thus, <code class=scheme><span class=variable>caar</span></code> stands for ``<code class=scheme><span class=variable>car</span></code> of <code class=scheme><span class=variable>car</span></code> of'',
and <code class=scheme><span class=variable>cdar</span></code> stands for ``<code class=scheme><span class=variable>cdr</span></code> of <code class=scheme><span class=variable>car</span></code> of'', etc.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>caar</span> <span class=variable>y</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>1</span>

(<span class=variable>cdar</span> <span class=variable>y</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>2</span>
</pre><p></p>
<p>
<code class=scheme><span class=variable>c...r</span></code>-style abbreviations for upto four cascades are
guaranteed to exist.  Thus, <code class=scheme><span class=variable>cadr</span></code>, <code class=scheme><span class=variable>cdadr</span></code>, and
<code class=scheme><span class=variable>cdaddr</span></code> are all valid.  <code class=scheme><span class=variable>cdadadr</span></code> might be pushing it.</p>
<p>
When nested dotting occurs along the second element,
Scheme uses a special notation to represent the
resulting expression:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>cons</span> <span class=selfeval>1</span> (<span class=variable>cons</span> <span class=selfeval>2</span> (<span class=variable>cons</span> <span class=selfeval>3</span> (<span class=variable>cons</span> <span class=selfeval>4</span> <span class=selfeval>5</span>))))
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span> . <span class=selfeval>5</span>)
</pre><p></p>
<p>
Ie, <code class=scheme>(<span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span> . <span class=selfeval>5</span>)</code> is an abbreviation for <code class=scheme>(<span class=selfeval>1</span>
. (<span class=selfeval>2</span> . (<span class=selfeval>3</span> . (<span class=selfeval>4</span> . <span class=selfeval>5</span>))))</code>.  The last cdr of this
expression is <code class=scheme><span class=selfeval>5</span></code>.</p>
<p>
<a name="node_idx_200"></a></p>
<p>
Scheme provides a further abbreviation if the last cdr
is a special object called the <em>empty list</em>, which
is represented by the expression <code class=scheme>()</code>.  The empty
list is not considered self-evaluating, and so one
should quote it when supplying it as a value in a
program:</p>
<p>
</p>
<pre class=scheme><span class=keyword>'</span>() <font color="teal"><tt><strong>=&gt;</strong></tt></font>  ()
</pre><p></p>
<p>
The abbreviation for a dotted pair of the form <code class=scheme>(<span class=selfeval>1</span>
. (<span class=selfeval>2</span> . (<span class=selfeval>3</span> . (<span class=selfeval>4</span> . ()))))</code> is</p>
<p>
</p>
<pre class=scheme>(<span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
</pre><p></p>
<p>
<a name="node_idx_202"></a>
This special kind of nested dotted pair is called a
<em>list</em>.  This particular list is four elements
long.  It could have been created by saying</p>
<p>
</p>
<pre class=scheme>(<span class=variable>cons</span> <span class=selfeval>1</span> (<span class=variable>cons</span> <span class=selfeval>2</span> (<span class=variable>cons</span> <span class=selfeval>3</span> (<span class=variable>cons</span> <span class=selfeval>4</span> <span class=keyword>'</span>()))))
</pre><p></p>
<p>
but Scheme provides a procedure called <code class=scheme><span class=variable>list</span></code> that
makes list creation more convenient.  <code class=scheme><span class=variable>list</span></code> takes
any number of arguments and returns the list containing
them:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>list</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
</pre><p></p>
<p>
Indeed, if we know all the elements of a list, we can use
<code class=scheme><span class=keyword>quote</span></code> to specify the list:</p>
<p>
</p>
<pre class=scheme><span class=keyword>'</span>(<span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
</pre><p></p>
<p>
<a name="node_idx_204"></a>
<a name="node_idx_206"></a>
List elements can be accessed by index.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>y</span> (<span class=variable>list</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>))

(<span class=variable>list-ref</span> <span class=variable>y</span> <span class=selfeval>0</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>1</span>
(<span class=variable>list-ref</span> <span class=variable>y</span> <span class=selfeval>3</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>4</span>

(<span class=variable>list-tail</span> <span class=variable>y</span> <span class=selfeval>1</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span>)
(<span class=variable>list-tail</span> <span class=variable>y</span> <span class=selfeval>3</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>4</span>)
</pre><p></p>
<p>
<code class=scheme><span class=variable>list-tail</span></code> returns the <em>tail</em> of the list
starting from the given index.</p>
<p>
<a name="node_idx_208"></a>
<a name="node_idx_210"></a>
<a name="node_idx_212"></a></p>
<p>
The predicates <code class=scheme><span class=variable>pair?</span></code>, <code class=scheme><span class=variable>list?</span></code>, and <code class=scheme><span class=variable>null?</span></code>
check if their argument is a dotted pair, list, or the
empty list, respectively:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>pair?</span> <span class=keyword>'</span>(<span class=selfeval>1</span> . <span class=selfeval>2</span>)) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>pair?</span> <span class=keyword>'</span>(<span class=selfeval>1</span> <span class=selfeval>2</span>))   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>pair?</span> <span class=keyword>'</span>())      <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>list?</span> <span class=keyword>'</span>())      <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>null?</span> <span class=keyword>'</span>())      <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>list?</span> <span class=keyword>'</span>(<span class=selfeval>1</span> <span class=selfeval>2</span>))   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#t</span>
(<span class=variable>list?</span> <span class=keyword>'</span>(<span class=selfeval>1</span> . <span class=selfeval>2</span>)) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>null?</span> <span class=keyword>'</span>(<span class=selfeval>1</span> <span class=selfeval>2</span>))   <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
(<span class=variable>null?</span> <span class=keyword>'</span>(<span class=selfeval>1</span> . <span class=selfeval>2</span>)) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
</p>
<a name="node_sec_2.2.4"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.2.4">2.2.4&nbsp;&nbsp;Conversions between data types</a></h3>
<p><a name="node_idx_214"></a>
<a name="node_idx_216"></a>
<a name="node_idx_218"></a>
<a name="node_idx_220"></a>
<a name="node_idx_222"></a>
<a name="node_idx_224"></a>
<a name="node_idx_226"></a>
<a name="node_idx_228"></a>
<a name="node_idx_230"></a>
Scheme offers many procedures for converting among
the data types.  We already know how to convert between
the character cases using <code class=scheme><span class=variable>char-downcase</span></code> and
<code class=scheme><span class=variable>char-upcase</span></code>.  Characters can be converted into
integers using <code class=scheme><span class=variable>char-&gt;integer</span></code>, and integers can be
converted into characters using <code class=scheme><span class=variable>integer-&gt;char</span></code>.
(The integer corresponding to a character is usually
its ascii code.)</p>
<p>
</p>
<pre class=scheme>(<span class=variable>char-&gt;integer</span> <span class=selfeval>#\d</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>100</span>
(<span class=variable>integer-&gt;char</span> <span class=selfeval>50</span>)  <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#\2</span>
</pre><p></p>
<p>
Strings can be converted into the corresponding list of
characters.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>string-&gt;list</span> <span class=selfeval>&quot;hello&quot;</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  (<span class=selfeval>#\h</span> <span class=selfeval>#\e</span> <span class=selfeval>#\l</span> <span class=selfeval>#\l</span> <span class=selfeval>#\o</span>)
</pre><p></p>
<p>
Other conversion procedures in the same vein are
<code class=scheme><span class=variable>list-&gt;string</span></code>, <code class=scheme><span class=variable>vector-&gt;list</span></code>, and
<code class=scheme><span class=variable>list-&gt;vector</span></code>.</p>
<p>
Numbers can be converted to strings:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>number-&gt;string</span> <span class=selfeval>16</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;16&quot;</span>
</pre><p></p>
<p>
Strings can be converted to numbers.  If the string
corresponds to no number, <code class=scheme><span class=selfeval>#f</span></code> is returned.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>string-&gt;number</span> <span class=selfeval>&quot;16&quot;</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>16</span>

(<span class=variable>string-&gt;number</span> <span class=selfeval>&quot;Am I a hot number?&quot;</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>#f</span>
</pre><p></p>
<p>
<code class=scheme><span class=variable>string-&gt;number</span></code> takes an optional second argument,
the radix.</p>
<p>
</p>
<pre class=scheme>(<span class=variable>string-&gt;number</span> <span class=selfeval>&quot;16&quot;</span> <span class=selfeval>8</span>) <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>14</span>
</pre><p></p>
<p>
because <code class=scheme><span class=selfeval>16</span></code> in base 8 is the number fourteen.</p>
<p>
Symbols can be converted to strings, and vice versa:</p>
<p>
</p>
<pre class=scheme>(<span class=variable>symbol-&gt;string</span> <span class=keyword>'</span><span class=variable>symbol</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;symbol&quot;</span>

(<span class=variable>string-&gt;symbol</span> <span class=selfeval>&quot;string&quot;</span>)
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=variable>string</span>
</pre><p></p>
<p>
</p>
<a name="node_sec_2.3"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.3">2.3&nbsp;&nbsp;Other data types</a></h2>
<p><a name="node_idx_232"></a>
Scheme contains some other data types.  One is the
<em>procedure</em>.  We have already seen many procedures, eg,
<code class=scheme><span class=variable>display</span></code>, <code class=scheme><span class=variable>+</span></code>, <code class=scheme><span class=variable>cons</span></code>.  In reality, these are
variables holding the procedure values, which are
themselves not visible as are numbers or characters:</p>
<p>
</p>
<pre class=scheme><span class=variable>cons</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=variable>&lt;procedure&gt;</span>
</pre><p></p>
<p>
The procedures we have seen thus far are <em>primitive</em>
procedures, with standard global variables holding them.
Users can create additional procedure values.</p>
<p>
<a name="node_idx_234"></a></p>
<p>
Yet another data type is the <em>port</em>.  A port is the
conduit through which input and output is performed.
Ports are usually associated with files and consoles.</p>
<p>
In our ``Hello, World!'' program, we used the
procedure <code class=scheme><span class=variable>display</span></code> to write a string to the console.
<code class=scheme><span class=variable>display</span></code> can take two arguments, one the value to be
displayed, and the other the output port it should be
displayed on.</p>
<p>
In our program, <code class=scheme><span class=variable>display</span></code>'s second argument was
implicit.  The default output port used is the standard
output port.  We can get the current standard output
port via the procedure-call <code class=scheme>(<span class=variable>current-output-port</span>)</code>.
We could have been more explicit and written</p>
<p>
</p>
<pre class=scheme>(<span class=variable>display</span> <span class=selfeval>&quot;Hello, World!&quot;</span> (<span class=variable>current-output-port</span>))
</pre><p></p>
<p>
<a name="node_idx_236"></a></p>
<p>
</p>
<a name="node_sec_2.4"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_2.4">2.4&nbsp;&nbsp;S-expressions</a></h2>
<p>All the data types discussed here can be lumped
together into a single all-encompassing data type
called the <em>s-expression</em> (<em>s</em> for <em>symbolic</em>).  Thus <code class=scheme><span class=selfeval>42</span></code>, <code class=scheme><span class=selfeval>#\c</span></code>, <code class=scheme>(<span class=selfeval>1</span> . <span class=selfeval>2</span>)</code>, <code class=scheme><span class=selfeval>#</span>(<span class=variable>a</span>
<span class=variable>b</span> <span class=variable>c</span>)</code>, <code class=scheme><span class=selfeval>&quot;Hello&quot;</span></code>, <code class=scheme>(<span class=keyword>quote</span> <span class=variable>xyz</span>)</code>,
<code class=scheme>(<span class=variable>string-&gt;number</span> <span class=selfeval>&quot;16&quot;</span>)</code>, and <code class=scheme>(<span class=keyword>begin</span>
(<span class=variable>display</span> <span class=selfeval>&quot;Hello, World!&quot;</span>) (<span class=variable>newline</span>))</code> are all s-expressions.
</p>
<p>
</p>
<div align=right class=navigation><i>[Go to <span><a href="t-y-scheme.html">first</a>, <a href="t-y-scheme-Z-H-3.html">previous</a></span><span>, <a href="t-y-scheme-Z-H-5.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="t-y-scheme-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="t-y-scheme-Z-H-25.html#node_index_start">index</a></span>]</i></div><p></p>
</body>
</html>
