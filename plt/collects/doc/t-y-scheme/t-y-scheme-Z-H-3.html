<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from t-y-scheme.tex by tex2page, v 2004-09-11
(running on MzScheme 209, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Teach Yourself Scheme in Fixnum Days
</title>
<link rel="stylesheet" type="text/css" href="t-y-scheme-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
<meta name=description content="A practical
introduction to the programming language Scheme">

<meta name=author content="Dorai Sitaram">

<link rev=made href="mailto:dorai @ ccs.neu.edu">
</head>
<body>
<div align=right class=navigation><i>[Go to <span><a href="t-y-scheme.html">first</a>, <a href="t-y-scheme-Z-H-2.html">previous</a></span><span>, <a href="t-y-scheme-Z-H-4.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="t-y-scheme-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="t-y-scheme-Z-H-25.html#node_index_start">index</a></span>]</i></div><p></p>
<a name="node_chap_1"></a>
<h1 class=chapter>
<div class=chapterheading><a href="t-y-scheme-Z-H-1.html#node_toc_node_chap_1">Chapter 1</a></div><br>
<a href="t-y-scheme-Z-H-1.html#node_toc_node_chap_1">Enter Scheme</a></h1>
<p></p>
<p>
<a name="node_idx_8"></a>
<a name="node_idx_10"></a>
<a name="node_idx_12"></a>
The canonical first program is the one that says
<code class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span></code> on the console.  Using your 
favorite editor, create a file called
<code class=verbatim>hello.scm</code> with the following contents:</p>
<p>
</p>
<pre class=scheme><span class=comment>;The first program</span>

(<span class=keyword>begin</span>
  (<span class=variable>display</span> <span class=selfeval>&quot;Hello, World!&quot;</span>)
  (<span class=variable>newline</span>))
</pre><p></p>
<p>
<a name="node_idx_14"></a>
The first line is a comment.  When Scheme sees a
semicolon, it ignores it and all the following text on
the line.</p>
<p>
<a name="node_idx_16"></a>
<a name="node_idx_18"></a>
<a name="node_idx_20"></a>
<a name="node_idx_22"></a></p>
<p>
The <code class=scheme><span class=keyword>begin</span></code>-<em>form</em> is Scheme's way of
introducing a sequence of <em>subforms</em>.  In this
case there are two subforms.  The first is a call to
the 
<code class=scheme><span class=variable>display</span></code> procedure that outputs its argument
(the string <code class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span></code>) to the console (or
``standard output'').  It is followed by a <code class=scheme><span class=variable>newline</span></code>
procedure call, which outputs a carriage return.</p>
<p>
<a name="node_idx_24"></a>
<a name="node_idx_26"></a></p>
<p>
To run this program, first start your Scheme.  This is
usually done by  typing the name of your Scheme
executable at the operating-system command line.
Eg, in the case of MzScheme [<a href="t-y-scheme-Z-H-24.html#node_bib_9">9</a>],
you type</p>
<p>
</p>
<pre class=verbatim>mzscheme&nbsp;
</pre><p></p>
<p>
at the operating-system prompt.</p>
<p>
<a name="node_idx_28"></a>
<a name="node_idx_30"></a>
<a name="node_idx_32"></a></p>
<p>
This invokes the Scheme <em>listener</em>, which <em>read</em>s
your input, <em>eval</em>uates it, <em>print</em>s the result (if
any), and then waits for more input from you.  For this
reason, it is often called the <em>read-eval-print loop</em>.
Note that this is not much different from your
operating-system command line, which also reads your
commands, executes them, and then waits for more.  Like the
operating system, the Scheme listener has its own prompt  -- 
usually this is
<code class=verbatim>&gt;</code>, but could be something else.</p>
<p>
<a name="node_idx_34"></a></p>
<p>
At the listener prompt, <em>load</em> the file
<code class=verbatim>hello.scm</code>.  This is done by typing</p>
<p>
</p>
<pre class=scheme>(<span class=variable>load</span> <span class=selfeval>&quot;hello.scm&quot;</span>)
</pre><p></p>
<p>
Scheme will now execute the contents of
<code class=verbatim>hello.scm</code>, outputting <code class=verbatim>Hello, World!</code> followed
by a carriage return.  After this, you will get the listener
prompt again, waiting for more input from you.</p>
<p>
Since you have such an eager listener, you need not
always write your programs in a file and load them.
Sometimes, it is easier, especially when you are in an
exploring mood, to simply type expressions directly at
the listener prompt and see what happens.  For example,
typing the form</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>begin</span> (<span class=variable>display</span> <span class=selfeval>&quot;Hello, World!&quot;</span>)
       (<span class=variable>newline</span>))
</pre><p></p>
<p>
at the Scheme prompt produces</p>
<p>
</p>
<pre class=verbatim>Hello, World!&nbsp;
</pre><p></p>
<p>
Actually, you could simply have typed the form
<code class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span></code> at the listener, and you would have
obtained as result the string</p>
<p>
</p>
<pre class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span>
</pre><p></p>
<p>
because that is the result of the listener evaluating
<code class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span></code>.</p>
<p>
Other than the fact that the second approach produces a
result with double-quotes around it, there is one other
significant difference between the last two programs.
The first (ie, the one with the <code class=scheme><span class=keyword>begin</span></code>) does not evaluate
to anything  --  the <code class=verbatim>Hello, World!</code> it emits is a
<em>side-effect</em> produced by the <code class=scheme><span class=variable>display</span></code> and
<code class=scheme><span class=variable>newline</span></code> procedures writing to the standard output.
In the second program, the form
<code class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span></code> <em>evaluates</em> to the result, which
in this case is the same string as the form.</p>
<p>
Henceforth, we will use the notation <code class=scheme><font color="teal"><tt><strong>=&gt;</strong></tt></font> </code> to denote
evaluation.  Thus</p>
<p>
</p>
<pre class=scheme><span class=variable>E</span> <font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=variable>v</span>
</pre><p></p>
<p>
indicates that the form <code class=scheme><span class=variable>E</span></code> evaluates to a result value
of <code class=scheme><span class=variable>v</span></code>.  Eg,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>begin</span>
  (<span class=variable>display</span> <span class=selfeval>&quot;Hello, World!&quot;</span>)
  (<span class=variable>newline</span>))
<font color="teal"><tt><strong>=&gt;</strong></tt></font> 
</pre><p></p>
<p>
(ie, nothing or void), although it has the side-effect of writing</p>
<p>
</p>
<pre class=verbatim>Hello, World!&nbsp;
</pre><p></p>
<p>
to the standard output.
On the other hand,</p>
<p>
</p>
<pre class=scheme><span class=selfeval>&quot;Hello, World!&quot;</span>
<font color="teal"><tt><strong>=&gt;</strong></tt></font>  <span class=selfeval>&quot;Hello, World!&quot;</span>
</pre><p></p>
<p>
In either case, we are still at the listener.  To exit,
type</p>
<p>
<a name="node_idx_36"></a>
</p>
<pre class=scheme>(<span class=variable>exit</span>)
</pre><p></p>
<p>
and this will land you back at the operating-system
command-line (which, as we've seen, is also a kind of
listener).</p>
<p>
The listener is convenient for interactive testing of
programs and program fragments.  However it is by no
means necessary.  You may certainly stick to the
tradition of creating programs in their entirety in
files, and having Scheme execute them without any
explicit ``listening''.  In MzScheme, for instance, you
could say (at the operating-system prompt)</p>
<p>
</p>
<pre class=verbatim>mzscheme -r hello.scm&nbsp;
</pre><p></p>
<p>
and this will produce the greeting without making you
deal with
the listener.   After the greeting, <code class=verbatim>mzscheme</code> will
return you to the
operating-system prompt.  This is almost as if you said</p>
<p>
</p>
<pre class=verbatim>echo Hello, World!&nbsp;
</pre><p></p>
<p>
You could even make <code class=verbatim>hello.scm</code> seem like an
operating-system command (a shell script or a
batch file), but that will have to wait till
chapter&nbsp;<a href="t-y-scheme-Z-H-18.html#node_chap_16">16</a>.</p>
<p>
</p>
<p>
</p>
<div align=right class=navigation><i>[Go to <span><a href="t-y-scheme.html">first</a>, <a href="t-y-scheme-Z-H-2.html">previous</a></span><span>, <a href="t-y-scheme-Z-H-4.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="t-y-scheme-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="t-y-scheme-Z-H-25.html#node_index_start">index</a></span>]</i></div><p></p>
</body>
</html>
