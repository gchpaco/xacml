<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from t-y-scheme.tex by tex2page, v 2004-09-11
(running on MzScheme 209, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Teach Yourself Scheme in Fixnum Days
</title>
<link rel="stylesheet" type="text/css" href="t-y-scheme-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
<meta name=description content="A practical
introduction to the programming language Scheme">

<meta name=author content="Dorai Sitaram">

<link rev=made href="mailto:dorai @ ccs.neu.edu">
</head>
<body>
<div align=right class=navigation><i>[Go to <span><a href="t-y-scheme.html">first</a>, <a href="t-y-scheme-Z-H-15.html">previous</a></span><span>, <a href="t-y-scheme-Z-H-17.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="t-y-scheme-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="t-y-scheme-Z-H-25.html#node_index_start">index</a></span>]</i></div><p></p>
<a name="node_chap_14"></a>
<h1 class=chapter>
<div class=chapterheading><a href="t-y-scheme-Z-H-1.html#node_toc_node_chap_14">Chapter 14</a></div><br>
<a href="t-y-scheme-Z-H-1.html#node_toc_node_chap_14">Nondeterminism</a></h1>
<p><a name="node_idx_466"></a>
<a name="node_idx_468"></a>
<a name="node_idx_470"></a>
McCarthy's nondeterministic operator
<code class=scheme><span class=keyword>amb</span></code> [<a href="t-y-scheme-Z-H-24.html#node_bib_25">25</a>,&nbsp;<a href="t-y-scheme-Z-H-24.html#node_bib_4">4</a>,&nbsp;<a href="t-y-scheme-Z-H-24.html#node_bib_33">33</a>] is as old as
Lisp itself, although it is present in no Lisp.
<code class=scheme><span class=keyword>amb</span></code> takes zero or more expressions, and makes a
nondeterministic (or ``ambiguous'') choice among them,
preferring those choices that cause the program to
converge meaningfully.  Here we will explore an
embedding of <code class=scheme><span class=keyword>amb</span></code> in Scheme that makes a depth-first
selection of the ambiguous choices, and uses Scheme's
control operator <code class=scheme><span class=variable>call/cc</span></code> to backtrack for alternate
choices.  The result is an elegant backtracking
strategy that can be used for searching problem spaces
directly in Scheme without recourse to an extended
language.  The embedding recalls the continuation
strategies used to implement Prolog-style logic
programming [<a href="t-y-scheme-Z-H-24.html#node_bib_16">16</a>,&nbsp;<a href="t-y-scheme-Z-H-24.html#node_bib_7">7</a>], but is sparer because the
operator provided is much like a Scheme boolean
operator, does not require special contexts for its
use, and does not rely on linguistic infrastructure
such as logic variables and unification.</p>
<p>
</p>
<a name="node_sec_14.1"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_14.1">14.1&nbsp;&nbsp;Description of <code class=scheme><span class=keyword>amb</span></code></a></h2>
<p>An accessible description of <code class=scheme><span class=keyword>amb</span></code> and many example
uses are found in the premier Scheme textbook
SICP [<a href="t-y-scheme-Z-H-24.html#node_bib_1">1</a>].  Informally,
<code class=scheme><span class=keyword>amb</span></code> takes zero or more expressions and <em>nondeterministically</em> returns the value of <em>one</em> of
them.  Thus,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span> <span class=selfeval>1</span> <span class=selfeval>2</span>)
</pre><p></p>
<p>
may evaluate to 1 <em>or</em> 2.</p>
<p>
<code class=scheme><span class=keyword>amb</span></code> called with <em>no</em> expressions has no
value to return, and is considered to <em>fail</em>.
Thus,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span>)
<font color="red"><tt><strong><i>--&gt;ERROR!!!</i></strong></tt></font> <span class=keyword>amb</span> <span class=variable>tree</span> <span class=variable>exhausted</span>
</pre><p></p>
<p>
(We will examine the wording of the error message later.)</p>
<p>
In particular, <code class=scheme><span class=keyword>amb</span></code> is required to return a value if at
least one its subexpressions converges, ie, doesn't fail.
Thus,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span> <span class=selfeval>1</span> (<span class=keyword>amb</span>))
</pre><p></p>
<p>
and</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span> (<span class=keyword>amb</span>) <span class=selfeval>1</span>)
</pre><p></p>
<p>
both return 1.</p>
<p>
Clearly, <code class=scheme><span class=keyword>amb</span></code> cannot simply be equated to its first
subexpression, since it has to return a <em>non-failing</em>
value, if this is at all possible.  However, this is not
all: The bias for convergence is more stringent than a
merely local choice of <code class=scheme><span class=keyword>amb</span></code>'s subexpressions.  <code class=scheme><span class=keyword>amb</span></code>
should furthermore return <em>that</em> convergent value
that makes the <em>entire program</em> converge.  In
denotational parlance, <code class=scheme><span class=keyword>amb</span></code> is an <em>angelic</em>
operator.</p>
<p>
For example,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span> <span class=selfeval>#f</span> <span class=selfeval>#t</span>)
</pre><p></p>
<p>
may return either <code class=scheme><span class=selfeval>#f</span></code> or <code class=scheme><span class=selfeval>#t</span></code>, but in the program</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>if</span> (<span class=keyword>amb</span> <span class=selfeval>#f</span> <span class=selfeval>#t</span>)
    <span class=selfeval>1</span>
    (<span class=keyword>amb</span>))
</pre><p></p>
<p>
the first <code class=scheme><span class=keyword>amb</span></code>-expression <em>must</em> return <code class=scheme><span class=selfeval>#t</span></code>.
If it returned <code class=scheme><span class=selfeval>#f</span></code>, the <code class=scheme><span class=keyword>if</span></code>'s ``else'' branch would be
chosen, which causes the entire program to fail.</p>
<p>
</p>
<a name="node_sec_14.2"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_14.2">14.2&nbsp;&nbsp;Implementing <code class=scheme><span class=keyword>amb</span></code> in Scheme</a></h2>
<p>In our implementation of <code class=scheme><span class=keyword>amb</span></code>, we will favor
<code class=scheme><span class=keyword>amb</span></code>'s subexpressions from left to right.  Ie, the
first subexpression is chosen, and if it leads to overall
failure, the second is picked, and so on.  <code class=scheme><span class=keyword>amb</span></code>s occurring
later in the control flow of the program are searched for
alternates before backtracking to previous <code class=scheme><span class=keyword>amb</span></code>s.  In
other words, we perform a <em>depth-first</em> search of the
<code class=scheme><span class=keyword>amb</span></code> <em>choice tree</em>, and whenever we brush against
failure, we backtrack to the most recent node of the tree
that offers a further choice.  (This is called <em>chronological backtracking.</em>)</p>
<p>
We first define a mechanism for setting the base failure
continuation:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>amb-fail</span> <span class=keyword>'</span><span class=variable>*</span>)

(<span class=keyword>define</span> <span class=variable>initialize-amb-fail</span>
  (<span class=keyword>lambda</span> ()
    (<span class=keyword>set!</span> <span class=variable>amb-fail</span>
      (<span class=keyword>lambda</span> ()
        (<span class=variable>error</span> <span class=selfeval>&quot;amb tree exhausted&quot;</span>)))))

(<span class=variable>initialize-amb-fail</span>)
</pre><p></p>
<p>
When <code class=scheme><span class=keyword>amb</span></code> fails, it invokes the continuation bound at
the time to <code class=scheme><span class=variable>amb-fail</span></code>.  This is the continuation invoked
when all the alternates in the <code class=scheme><span class=keyword>amb</span></code> choice tree have been
tried and were found to fail.</p>
<p>
We define <code class=scheme><span class=keyword>amb</span></code> as a macro that accepts an indefinite
number of subexpressions.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define-macro</span> <span class=keyword>amb</span>
  (<span class=keyword>lambda</span> <span class=variable>alts...</span>
    <span class=keyword>`</span>(<span class=keyword>let</span> ((<span class=variable>+prev-amb-fail</span> <span class=variable>amb-fail</span>))
       (<span class=variable>call/cc</span>
        (<span class=keyword>lambda</span> (<span class=variable>+sk</span>)

          <span class=keyword>,@</span>(<span class=variable>map</span> (<span class=keyword>lambda</span> (<span class=variable>alt</span>)
                   <span class=keyword>`</span>(<span class=variable>call/cc</span>
                     (<span class=keyword>lambda</span> (<span class=variable>+fk</span>)
                       (<span class=keyword>set!</span> <span class=variable>amb-fail</span>
                         (<span class=keyword>lambda</span> ()
                           (<span class=keyword>set!</span> <span class=variable>amb-fail</span> <span class=variable>+prev-amb-fail</span>)
                           (<span class=variable>+fk</span> <span class=keyword>'</span><span class=variable>fail</span>)))
                       (<span class=variable>+sk</span> <span class=keyword>,</span><span class=variable>alt</span>))))
                 <span class=variable>alts...</span>)

          (<span class=variable>+prev-amb-fail</span>))))))
</pre><p></p>
<p>
A call to <code class=scheme><span class=keyword>amb</span></code> first stores away, in
<code class=scheme><span class=variable>+prev-amb-fail</span></code>, the <code class=scheme><span class=variable>amb-fail</span></code> value that was
current at the time of entry.  This is because the
<code class=scheme><span class=variable>amb-fail</span></code> variable will be set to different failure
continuations as the various alternates are tried.</p>
<p>
We then capture the <code class=scheme><span class=keyword>amb</span></code>'s <em>entry</em> continuation <code class=scheme><span class=variable>+sk</span></code>, so
that when one of the alternates evaluates to a non-failing
value, it can immediately exit the <code class=scheme><span class=keyword>amb</span></code>.</p>
<p>
Each alternate <code class=scheme><span class=variable>alt</span></code> is tried in sequence (the
implicit-<code class=scheme><span class=keyword>begin</span></code> sequence of Scheme).</p>
<p>
First, we capture the current continuation <code class=scheme><span class=variable>+fk</span></code>, wrap it
in a procedure and set <code class=scheme><span class=variable>amb-fail</span></code> to that procedure.  The
alternate is then evaluated as <code class=scheme>(<span class=variable>+sk</span> <span class=variable>alt</span>)</code>.  If <code class=scheme><span class=variable>alt</span></code>
evaluates without failure, its return value is fed to the
continuation <code class=scheme><span class=variable>+sk</span></code>, which immediately exits the <code class=scheme><span class=keyword>amb</span></code>
call.  If <code class=scheme><span class=variable>alt</span></code> fails, it calls <code class=scheme><span class=variable>amb-fail</span></code>.  The first
duty of <code class=scheme><span class=variable>amb-fail</span></code> is to reset <code class=scheme><span class=variable>amb-fail</span></code> to the value
it had at the time of entry.  It then invokes the failure
continuation <code class=scheme><span class=variable>+fk</span></code>, which causes the next alternate, if
any, to be tried.</p>
<p>
If all alternates fail, the <code class=scheme><span class=variable>amb-fail</span></code> at <code class=scheme><span class=keyword>amb</span></code> entry,
which we had stored in <code class=scheme><span class=variable>+prev-amb-fail</span></code>, is
called.</p>
<p>
</p>
<a name="node_sec_14.3"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_14.3">14.3&nbsp;&nbsp;Using <code class=scheme><span class=keyword>amb</span></code> in Scheme</a></h2>
<p>To choose a number between 1 and 10, one could say</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span> <span class=selfeval>1</span> <span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>4</span> <span class=selfeval>5</span> <span class=selfeval>6</span> <span class=selfeval>7</span> <span class=selfeval>8</span> <span class=selfeval>9</span> <span class=selfeval>10</span>)
</pre><p></p>
<p>
To be sure, as a program, this will give 1, but
depending on the context, it could return any of the
mentioned numbers.</p>
<p>
The procedure <code class=scheme><span class=variable>number-between</span></code> is
a more abstract way to generate numbers from a given <code class=scheme><span class=variable>lo</span></code>
to a given <code class=scheme><span class=variable>hi</span></code> (inclusive):</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>number-between</span>
  (<span class=keyword>lambda</span> (<span class=variable>lo</span> <span class=variable>hi</span>)
    (<span class=keyword>let</span> <span class=variable>loop</span> ((<span class=variable>i</span> <span class=variable>lo</span>))
      (<span class=keyword>if</span> (<span class=variable>&gt;</span> <span class=variable>i</span> <span class=variable>hi</span>) (<span class=keyword>amb</span>)
          (<span class=keyword>amb</span> <span class=variable>i</span> (<span class=variable>loop</span> (<span class=variable>+</span> <span class=variable>i</span> <span class=selfeval>1</span>)))))))
</pre><p></p>
<p>
Thus <code class=scheme>(<span class=variable>number-between</span> <span class=selfeval>1</span> <span class=selfeval>6</span>)</code> will first
generate 1.  Should that fail, the <code class=scheme><span class=variable>loop</span></code> iterates,
producing 2.  Should <em>that</em> fail, we get 3, and
so on, until 6.  After 6, <code class=scheme><span class=variable>loop</span></code> is called with
the number 7, which being more than 6, invokes
<code class=scheme>(<span class=keyword>amb</span>)</code>, which causes final failure.   (Recall that
<code class=scheme>(<span class=keyword>amb</span>)</code> by itself guarantees
failure.)  At this point, the program containing the
call to
<code class=scheme>(<span class=variable>number-between</span> <span class=selfeval>1</span> <span class=selfeval>6</span>)</code> will backtrack to the
chronologically previous <code class=scheme><span class=keyword>amb</span></code>-call, and try to
satisfy <em>that</em> call in another fashion.</p>
<p>
The guaranteed failure of <code class=scheme>(<span class=keyword>amb</span>)</code> can be used to program
<em>assertions</em>.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>assert</span>
  (<span class=keyword>lambda</span> (<span class=variable>pred</span>)
    (<span class=keyword>if</span> (<span class=variable>not</span> <span class=variable>pred</span>) (<span class=keyword>amb</span>))))
</pre><p></p>
<p>
The call <code class=scheme>(<span class=variable>assert</span> <span class=variable>pred</span>)</code> insists that <code class=scheme><span class=variable>pred</span></code> be
true.  Otherwise it will cause the current <code class=scheme><span class=keyword>amb</span></code> choice
point to fail.<a name="call_footnote_Temp_9"></a><a href="#footnote_Temp_9"><sup><small>7</small></sup></a></p>
<p>
Here is a procedure using <code class=scheme><span class=variable>assert</span></code> that generates a prime
less than or equal to its argument <code class=scheme><span class=variable>hi</span></code>:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>gen-prime</span>
  (<span class=keyword>lambda</span> (<span class=variable>hi</span>)
    (<span class=keyword>let</span> ((<span class=variable>i</span> (<span class=variable>number-between</span> <span class=selfeval>2</span> <span class=variable>hi</span>)))
      (<span class=variable>assert</span> (<span class=variable>prime?</span> <span class=variable>i</span>))
      <span class=variable>i</span>)))
</pre><p></p>
<p>
This seems devilishly simple, except that when called as
a program with any number (say 20), it will produce the
uninteresting first solution, ie, 2.</p>
<p>
We would certainly like to get <em>all</em> the solutions,
not just the first.  In this case, we may want <em>all</em>
the primes below
20.  One way is to explicitly call the failure
continuation left after the program has produced its first
solution.  Thus,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span>)
<span class=keyword>=&gt;</span> <span class=selfeval>3</span>
</pre><p></p>
<p>
This leaves yet another failure continuation, which can
be called again for yet another solution:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>amb</span>)
<span class=keyword>=&gt;</span> <span class=selfeval>5</span>
</pre><p></p>
<p>
The problem with this method is that the program is
initially called at the Scheme prompt, and successive
solutions are also obtained by calling <code class=scheme><span class=keyword>amb</span></code> at the Scheme
prompt.  In effect, we are using different programs (we
cannot predict how many!), carrying over information from a
previous program to the next.  Instead, we would like to be
able to get these solutions as the return value of a
form that we can call in any context.  To this end, we
define the
<code class=scheme><span class=keyword>bag-of</span></code> macro, which returns all
the successful instantiations of its argument.  (If the argument
never succeeds, <code class=scheme><span class=keyword>bag-of</span></code> returns the empty list.)
Thus, we could say,</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>bag-of</span>
  (<span class=variable>gen-prime</span> <span class=selfeval>20</span>))
</pre><p></p>
<p>
and it would return</p>
<p>
</p>
<pre class=scheme>(<span class=selfeval>2</span> <span class=selfeval>3</span> <span class=selfeval>5</span> <span class=selfeval>7</span> <span class=selfeval>11</span> <span class=selfeval>13</span> <span class=selfeval>17</span> <span class=selfeval>19</span>)
</pre><p></p>
<p>
The <code class=scheme><span class=keyword>bag-of</span></code> macro is defined as follows:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define-macro</span> <span class=keyword>bag-of</span>
  (<span class=keyword>lambda</span> (<span class=variable>e</span>)
    <span class=keyword>`</span>(<span class=keyword>let</span> ((<span class=variable>+prev-amb-fail</span> <span class=variable>amb-fail</span>)
           (<span class=variable>+results</span> <span class=keyword>'</span>()))
       (<span class=keyword>if</span> (<span class=variable>call/cc</span>
            (<span class=keyword>lambda</span> (<span class=variable>+k</span>)
              (<span class=keyword>set!</span> <span class=variable>amb-fail</span> (<span class=keyword>lambda</span> () (<span class=variable>+k</span> <span class=selfeval>#f</span>)))
              (<span class=keyword>let</span> ((<span class=variable>+v</span> <span class=keyword>,</span><span class=variable>e</span>))
                (<span class=keyword>set!</span> <span class=variable>+results</span> (<span class=variable>cons</span> <span class=variable>+v</span> <span class=variable>+results</span>))
                (<span class=variable>+k</span> <span class=selfeval>#t</span>))))
           (<span class=variable>amb-fail</span>))
       (<span class=keyword>set!</span> <span class=variable>amb-fail</span> <span class=variable>+prev-amb-fail</span>)
       (<span class=variable>reverse!</span> <span class=variable>+results</span>))))
</pre><p></p>
<p>
<code class=scheme><span class=keyword>bag-of</span></code> first saves away its entry <code class=scheme><span class=variable>amb-fail</span></code>.  It
redefines <code class=scheme><span class=variable>amb-fail</span></code> to a local continuation <code class=scheme><span class=variable>+k</span></code> created within an
<code class=scheme><span class=keyword>if</span></code>-test.  Inside the test, the <code class=scheme><span class=keyword>bag-of</span></code> argument <code class=scheme><span class=variable>e</span></code>
is evaluated.
If <code class=scheme><span class=variable>e</span></code> succeeds, its result is collected
into a list called <code class=scheme><span class=variable>+results</span></code>, and the local continuation
is called with the value <code class=scheme><span class=selfeval>#t</span></code>.  This causes the
<code class=scheme><span class=keyword>if</span></code>-test to succeed, causing <code class=scheme><span class=variable>e</span></code> to be <em>retried</em> at its
next backtrack point.  More results for <code class=scheme><span class=variable>e</span></code> are obtained this
way, and they are all collected into <code class=scheme><span class=variable>+results</span></code>.</p>
<p>
Finally, when <code class=scheme><span class=variable>e</span></code> fails, it will call the base
<code class=scheme><span class=variable>amb-fail</span></code>, which is simply a call to the local
continuation with the value <code class=scheme><span class=selfeval>#f</span></code>.  This pushes control
past the <code class=scheme><span class=keyword>if</span></code>.   We restore <code class=scheme><span class=variable>amb-fail</span></code> to
its  pre-entry value, and return the <code class=scheme><span class=variable>+results</span></code>.  (The
<code class=scheme><span class=variable>reverse!</span></code> is simply to produce the results in the order
in which they were generated.)</p>
<p>
<a name="node_idx_472"></a>
</p>
<a name="node_sec_14.4"></a>
<h2><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_14.4">14.4&nbsp;&nbsp;Logic puzzles</a></h2>
<p>The power of depth-first search coupled
with backtracking becomes obvious when applied to solving
logic puzzles.  These problems are extraordinarily difficult
to solve procedurally, but can be solved concisely and
declaratively with <code class=scheme><span class=keyword>amb</span></code>, without taking anything away
from the charm of solving the puzzle.</p>
<p>
</p>
<a name="node_sec_14.4.1"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_14.4.1">14.4.1&nbsp;&nbsp;The Kalotan puzzle</a></h3>
<p>The Kalotans are a tribe with a peculiar quirk.<a name="call_footnote_Temp_10"></a><a href="#footnote_Temp_10"><sup><small>8</small></sup></a>  Their males always
tell the truth.  Their females never make two consecutive
true statements, or two consecutive untrue statements.</p>
<p>
An anthropologist (let's call him Worf) has begun to
study them.  Worf does not yet know the Kalotan
language.  One day, he meets a Kalotan (heterosexual)
couple and their child Kibi.  Worf asks Kibi: ``Are you
a boy?''  Kibi answers in Kalotan, which of course Worf
doesn't understand.</p>
<p>
Worf turns to the parents (who know English) for
explanation.  One of them says: ``Kibi said: `I am a
boy.' '' The other adds: ``Kibi is a girl.  Kibi lied.''</p>
<p>
Solve for the sex of the parents and Kibi.</p>
<p>
</p>
<div align=center>&nbsp; -- &nbsp;</div>
<p>
The solution consists in introducing a bunch of variables,
allowing them to take a choice of values, and
enumerating the conditions on them as a sequence of
<code class=scheme><span class=variable>assert</span></code> expressions.</p>
<p>
The variables: <code class=scheme><span class=variable>parent1</span></code>,
<code class=scheme><span class=variable>parent2</span></code>, and <code class=scheme><span class=variable>kibi</span></code> are the sexes of the parents (in
order of appearance) and Kibi; <code class=scheme><span class=variable>kibi-self-desc</span></code> is
the sex Kibi claimed to be (in Kalotan); <code class=scheme><span class=variable>kibi-lied?</span></code>
is the boolean on whether Kibi's claim was a lie.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>solve-kalotan-puzzle</span>
  (<span class=keyword>lambda</span> ()
    (<span class=keyword>let</span> ((<span class=variable>parent1</span> (<span class=keyword>amb</span> <span class=keyword>'</span><span class=variable>m</span> <span class=keyword>'</span><span class=variable>f</span>))
          (<span class=variable>parent2</span> (<span class=keyword>amb</span> <span class=keyword>'</span><span class=variable>m</span> <span class=keyword>'</span><span class=variable>f</span>))
          (<span class=variable>kibi</span> (<span class=keyword>amb</span> <span class=keyword>'</span><span class=variable>m</span> <span class=keyword>'</span><span class=variable>f</span>))
          (<span class=variable>kibi-self-desc</span> (<span class=keyword>amb</span> <span class=keyword>'</span><span class=variable>m</span> <span class=keyword>'</span><span class=variable>f</span>))
          (<span class=variable>kibi-lied?</span> (<span class=keyword>amb</span> <span class=selfeval>#t</span> <span class=selfeval>#f</span>)))
      (<span class=variable>assert</span>
       (<span class=variable>distinct?</span> (<span class=variable>list</span> <span class=variable>parent1</span> <span class=variable>parent2</span>)))
      (<span class=variable>assert</span>
       (<span class=keyword>if</span> (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>m</span>)
           (<span class=variable>not</span> <span class=variable>kibi-lied?</span>)))
      (<span class=variable>assert</span>
       (<span class=keyword>if</span> <span class=variable>kibi-lied?</span>
           (<span class=variable>xor</span>
            (<span class=keyword>and</span> (<span class=variable>eqv?</span> <span class=variable>kibi-self-desc</span> <span class=keyword>'</span><span class=variable>m</span>)
                 (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>f</span>))
            (<span class=keyword>and</span> (<span class=variable>eqv?</span> <span class=variable>kibi-self-desc</span> <span class=keyword>'</span><span class=variable>f</span>)
                 (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>m</span>)))))
      (<span class=variable>assert</span>
       (<span class=keyword>if</span> (<span class=variable>not</span> <span class=variable>kibi-lied?</span>)
           (<span class=variable>xor</span>
            (<span class=keyword>and</span> (<span class=variable>eqv?</span> <span class=variable>kibi-self-desc</span> <span class=keyword>'</span><span class=variable>m</span>)
                 (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>m</span>))
            (<span class=keyword>and</span> (<span class=variable>eqv?</span> <span class=variable>kibi-self-desc</span> <span class=keyword>'</span><span class=variable>f</span>)
                 (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>f</span>)))))
      (<span class=variable>assert</span>
       (<span class=keyword>if</span> (<span class=variable>eqv?</span> <span class=variable>parent1</span> <span class=keyword>'</span><span class=variable>m</span>)
           (<span class=keyword>and</span>
            (<span class=variable>eqv?</span> <span class=variable>kibi-self-desc</span> <span class=keyword>'</span><span class=variable>m</span>)
            (<span class=variable>xor</span>
             (<span class=keyword>and</span> (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>f</span>)
                  (<span class=variable>eqv?</span> <span class=variable>kibi-lied?</span> <span class=selfeval>#f</span>))
             (<span class=keyword>and</span> (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>m</span>)
                  (<span class=variable>eqv?</span> <span class=variable>kibi-lied?</span> <span class=selfeval>#t</span>))))))
      (<span class=variable>assert</span>
       (<span class=keyword>if</span> (<span class=variable>eqv?</span> <span class=variable>parent1</span> <span class=keyword>'</span><span class=variable>f</span>)
           (<span class=keyword>and</span>
            (<span class=variable>eqv?</span> <span class=variable>kibi</span> <span class=keyword>'</span><span class=variable>f</span>)
            (<span class=variable>eqv?</span> <span class=variable>kibi-lied?</span> <span class=selfeval>#t</span>))))
      (<span class=variable>list</span> <span class=variable>parent1</span> <span class=variable>parent2</span> <span class=variable>kibi</span>))))
</pre><p></p>
<p>
A note on the helper procedures: The procedure
<code class=scheme><span class=variable>distinct?</span></code> returns true if all the elements in its
argument list are distinct, and false otherwise.  The
procedure <code class=scheme><span class=variable>xor</span></code> returns true if only one of its two
arguments is true, and false otherwise.</p>
<p>
Typing <code class=scheme>(<span class=variable>solve-kalotan-puzzle</span>)</code> will solve the puzzle.</p>
<p>
</p>
<a name="node_sec_14.4.2"></a>
<h3><a href="t-y-scheme-Z-H-1.html#node_toc_node_sec_14.4.2">14.4.2&nbsp;&nbsp;Map coloring</a></h3>
<p>It has been known for some time (but not proven until
1976&nbsp;[<a href="t-y-scheme-Z-H-24.html#node_bib_29">29</a>]) that four colors suffice to
color a terrestrial map  --  ie, to color the countries
so that neighbors are distinguished.  To actually
assign the colors is still an undertaking, and the
following program shows how nondeterministic
programming can help.</p>
<p>
The following program solves the problem of coloring a
map of Western Europe.  The problem and a Prolog
solution are given in <em>The Art of
Prolog</em> [<a href="t-y-scheme-Z-H-24.html#node_bib_31">31</a>].  (It is instructive to compare
our solution with the book's.)</p>
<p>
</p>
<p>
The procedure <code class=scheme><span class=variable>choose-color</span></code> nondeterministically
returns one of four colors:</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>choose-color</span>
  (<span class=keyword>lambda</span> ()
    (<span class=keyword>amb</span> <span class=keyword>'</span><span class=variable>red</span> <span class=keyword>'</span><span class=variable>yellow</span> <span class=keyword>'</span><span class=variable>blue</span> <span class=keyword>'</span><span class=variable>white</span>)))
</pre><p></p>
<p>
In our solution, we create for each country a data
structure.  The data structure is a 3-element list: The
first element of the list is the country's name; the
second element is its assigned color; and the third
element is the colors of its neighbors.  Note we use
the initial of the country for its color
variable.<a name="call_footnote_Temp_11"></a><a href="#footnote_Temp_11"><sup><small>9</small></sup></a>  Eg, the list for Belgium is
<code class=scheme>(<span class=variable>list</span> <span class=keyword>'</span><span class=variable>belgium</span> <span class=variable>b</span> (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>h</span> <span class=variable>l</span> <span class=variable>g</span>))</code>, because  --  per
the problem statement  --  the neighbors of Belgium are
France, Holland, Luxembourg, and Germany.</p>
<p>
Once we create the lists for each country, we state the
(single!) condition they should satisfy, viz, no
country should have the color of its neighbors.  In
other words, for every country list, the second element
should not be a member of the third element.</p>
<p>
</p>
<pre class=scheme>(<span class=keyword>define</span> <span class=variable>color-europe</span>
  (<span class=keyword>lambda</span> ()

    <span class=comment>;choose colors for each country</span>
    (<span class=keyword>let</span> ((<span class=variable>p</span> (<span class=variable>choose-color</span>)) <span class=comment>;Portugal</span>
          (<span class=variable>e</span> (<span class=variable>choose-color</span>)) <span class=comment>;Spain</span>
          (<span class=variable>f</span> (<span class=variable>choose-color</span>)) <span class=comment>;France</span>
          (<span class=variable>b</span> (<span class=variable>choose-color</span>)) <span class=comment>;Belgium</span>
          (<span class=variable>h</span> (<span class=variable>choose-color</span>)) <span class=comment>;Holland</span>
          (<span class=variable>g</span> (<span class=variable>choose-color</span>)) <span class=comment>;Germany</span>
          (<span class=variable>l</span> (<span class=variable>choose-color</span>)) <span class=comment>;Luxemb</span>
          (<span class=variable>i</span> (<span class=variable>choose-color</span>)) <span class=comment>;Italy</span>
          (<span class=variable>s</span> (<span class=variable>choose-color</span>)) <span class=comment>;Switz</span>
          (<span class=variable>a</span> (<span class=variable>choose-color</span>)) <span class=comment>;Austria</span>
          )

      <span class=comment>;construct the adjacency list for</span>
      <span class=comment>;each country: the 1st element is</span>
      <span class=comment>;the name of the country; the 2nd</span>
      <span class=comment>;element is its color; the 3rd</span>
      <span class=comment>;element is the list of its</span>
      <span class=comment>;neighbors' colors</span>
      (<span class=keyword>let</span> ((<span class=variable>portugal</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>portugal</span> <span class=variable>p</span>
                   (<span class=variable>list</span> <span class=variable>e</span>)))
            (<span class=variable>spain</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>spain</span> <span class=variable>e</span>
                   (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>p</span>)))
            (<span class=variable>france</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>france</span> <span class=variable>f</span>
                   (<span class=variable>list</span> <span class=variable>e</span> <span class=variable>i</span> <span class=variable>s</span> <span class=variable>b</span> <span class=variable>g</span> <span class=variable>l</span>)))
            (<span class=variable>belgium</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>belgium</span> <span class=variable>b</span>
                   (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>h</span> <span class=variable>l</span> <span class=variable>g</span>)))
            (<span class=variable>holland</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>holland</span> <span class=variable>h</span>
                   (<span class=variable>list</span> <span class=variable>b</span> <span class=variable>g</span>)))
            (<span class=variable>germany</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>germany</span> <span class=variable>g</span>
                   (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>a</span> <span class=variable>s</span> <span class=variable>h</span> <span class=variable>b</span> <span class=variable>l</span>)))
            (<span class=variable>luxembourg</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>luxembourg</span> <span class=variable>l</span>
                   (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>b</span> <span class=variable>g</span>)))
            (<span class=variable>italy</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>italy</span> <span class=variable>i</span>
                   (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>a</span> <span class=variable>s</span>)))
            (<span class=variable>switzerland</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>switzerland</span> <span class=variable>s</span>
                   (<span class=variable>list</span> <span class=variable>f</span> <span class=variable>i</span> <span class=variable>a</span> <span class=variable>g</span>)))
            (<span class=variable>austria</span>
             (<span class=variable>list</span> <span class=keyword>'</span><span class=variable>austria</span> <span class=variable>a</span>
                   (<span class=variable>list</span> <span class=variable>i</span> <span class=variable>s</span> <span class=variable>g</span>))))
        (<span class=keyword>let</span> ((<span class=variable>countries</span>
               (<span class=variable>list</span> <span class=variable>portugal</span> <span class=variable>spain</span>
                     <span class=variable>france</span> <span class=variable>belgium</span>
                     <span class=variable>holland</span> <span class=variable>germany</span>
                     <span class=variable>luxembourg</span>
                     <span class=variable>italy</span> <span class=variable>switzerland</span>
                     <span class=variable>austria</span>)))

          <span class=comment>;the color of a country</span>
          <span class=comment>;should not be the color of</span>
          <span class=comment>;any of its neighbors</span>
          (<span class=variable>for-each</span>
           (<span class=keyword>lambda</span> (<span class=variable>c</span>)
             (<span class=variable>assert</span>
              (<span class=variable>not</span> (<span class=variable>memq</span> (<span class=variable>cadr</span> <span class=variable>c</span>)
                         (<span class=variable>caddr</span> <span class=variable>c</span>)))))
           <span class=variable>countries</span>)

          <span class=comment>;output the color</span>
          <span class=comment>;assignment</span>
          (<span class=variable>for-each</span>
           (<span class=keyword>lambda</span> (<span class=variable>c</span>)
             (<span class=variable>display</span> (<span class=variable>car</span> <span class=variable>c</span>))
             (<span class=variable>display</span> <span class=selfeval>&quot; &quot;</span>)
             (<span class=variable>display</span> (<span class=variable>cadr</span> <span class=variable>c</span>))
             (<span class=variable>newline</span>))
           <span class=variable>countries</span>))))))
</pre><p></p>
<p>
Type <code class=scheme>(<span class=variable>color-europe</span>)</code> to get a color assignment.
</p>
<p>
</p>
<div class=footnoterule><hr></div><p></p>
<div class=footnote><p><a name="footnote_Temp_9"></a><a href="#call_footnote_Temp_9"><sup><small>7</small></sup></a> SICP names this procedure
<code class=scheme><span class=variable>require</span></code>.  We use the identifier <code class=scheme><span class=variable>assert</span></code> in order to
avoid confusion with the popular if informal use of
the identifier <code class=scheme><span class=variable>require</span></code> for something else, viz, an
operator that loads code modules on a per-need basis.</p>
<p><a name="footnote_Temp_10"></a><a href="#call_footnote_Temp_10"><sup><small>8</small></sup></a> This
puzzle is due to Hunter [<a href="t-y-scheme-Z-H-24.html#node_bib_19">19</a>].</p>
<p><a name="footnote_Temp_11"></a><a href="#call_footnote_Temp_11"><sup><small>9</small></sup></a> Spain (Espa&ntilde;a) has <code class=scheme><span class=variable>e</span></code> so as not to
clash with Switzerland.</p>
</div>
<div align=right class=navigation><i>[Go to <span><a href="t-y-scheme.html">first</a>, <a href="t-y-scheme-Z-H-15.html">previous</a></span><span>, <a href="t-y-scheme-Z-H-17.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="t-y-scheme-Z-H-1.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="t-y-scheme-Z-H-25.html#node_index_start">index</a></span>]</i></div><p></p>
</body>
</html>
