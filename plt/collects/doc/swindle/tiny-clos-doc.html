<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Generated by Swindle/html (http://www.barzilay.org/Swindle/) -->
<html>
<head>
  <title>Documentation for 'swindle/tiny-clos.ss'</title>
</head>
<body bgcolor="#C0C0FF" text="#000000" link="#B00000" vlink="#600000" alink="#FF0000">
<h1 align="center">Documentation for '<tt>swindle/tiny-clos.ss</tt>'</h1>
<hr>
<p>
This module is the core object system.  It is a heavily hacked version
of the original Tiny-CLOS code from Xerox, but it has been fitted to
MzScheme, optimized and extended.  See the source file for a lot of
details about how the CLOS magic is created.
</p>
<p>
[There is one difference between Swindle and Tiny-CLOS: the meta object
hierarchy is assumed to be using only single inheritance, or if there is
multiple inheritance then the built in meta objects should come first to
make the slots allocated in the same place.  This should not be a
problem in realistic situations.]
</p>
<hr>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="172"><tt><b>???</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[value]</td>
  </tr>
</table>
<pre>  This is MzScheme's '<tt>unspecified</tt>' value which is used as the default
  value for unbound slots.  It is provided so you can check if a slot is
  unbound.
</pre>
<h3>Low level functionality</h3>
<pre>(These functions should be used with caution, since they make shooting
legs in exotic ways extremely easy.)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="173"><tt><b>(change-class! object new-class initargs ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  This operation changes the class of the given '<tt>object</tt>' to the given
  '<tt>new-class</tt>'.  The way this is done is by creating a fresh instance of
  '<tt>new-class</tt>', then copying all slot values from '<tt>object</tt>' to the new
  instance for all shared slot names.  Finally, the new instance's set
  of slots is used for the original object with the new class, so it
  preserves its identity.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="174"><tt><b>(set-instance-proc! object proc)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  This function sets the procedure of an entity object.  It is useful
  only for making new entity classes.
</pre>
<h3>Basic functionality</h3>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="175"><tt><b>(instance? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="176"><tt><b>(object? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  These two are synonyms: a predicate that returns #t for objects that
  are allocated and managed by Swindle.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="177"><tt><b>(class-of x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Return the class object of '<tt>x</tt>'.  This will either be a Swindle class
  for objects, or a built-in class for other Scheme values.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="178"><tt><b>(slot-ref obj slot)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Pull out the contents of the slot named '<tt>slot</tt>' in the given '<tt>obj</tt>'.
  Note that slot names are usually symbols, but can be other values as
  well.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="179"><tt><b>(slot-set! obj slot new)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Change the contents of the '<tt>slot</tt>' slot of '<tt>obj</tt>' to the given '<tt>new</tt>'
  value.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="180"><tt><b>(set-slot-ref! obj slot new)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  An alias for '<a href="tiny-clos-doc.html#179" title="Documentation for 'swindle/slot-set!.ss'"><tt>slot-set!</tt></a>', to enable using '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' on it.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="181"><tt><b>(slot-bound? object slot)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Checks if the given '<tt>slot</tt>' is bound in '<tt>object</tt>'.  See also '<a href="tiny-clos-doc.html#172" title="Documentation for 'swindle/???.ss'"><tt>???</tt></a>'
  above.
</pre>
<hr>
<a name="182"><h2>Singleton and Struct Specifiers</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="183"><tt><b>(singleton x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Returns a singleton specification.  Singletons can be used as type
  specifications that have only one element in them so you can
  specialize methods on unique objects.

  This is actually just a list with the symbol '<a href="tiny-clos-doc.html#183" title="Documentation for 'swindle/singleton.ss'"><tt>singleton</tt></a>' in its head
  and the value, but this function uses a hash table to always return
  the same object for the same value.  For example:
    =&gt; (singleton 1)
    (singleton 1)
    =&gt; (eq? (singleton 1) (singleton 1))
    #t
  but if the input objects are not '<tt>eq?</tt>', the result isn't either:
    =&gt; (eq? (singleton &quot;1&quot;) (singleton &quot;1&quot;))
    #f
  Only '<tt>eq?</tt>' is used to compare objects.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="184"><tt><b>(singleton? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Determines if something is a singleton specification (which is any
  list with a head containing the symbol '<a href="tiny-clos-doc.html#183" title="Documentation for 'swindle/singleton.ss'"><tt>singleton</tt></a>').
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="185"><tt><b>(singleton-value x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Pulls out the value of a singleton specification.
</pre>
<pre>Also note that MzScheme struct types are converted to appropriate
Swindle classes.  This way, it is possible to have Swindle generic
functions that work with struct type specializers.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="186"><tt><b>(struct-type-&gt;class struct-type)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  This function is used to convert a struct-type to a corresponding
  Swindle subclass of '<a href="tiny-clos-doc.html#187" title="Documentation for 'swindle/<struct>.ss'"><tt>&lt;struct&gt;</tt></a>'.  See the MzScheme manual for details
  on struct types.
</pre>
<h3>Common accessors</h3>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="188"><tt><b>(class-direct-slots class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="189"><tt><b>(class-direct-supers class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="190"><tt><b>(class-slots class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="191"><tt><b>(class-cpl class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="192"><tt><b>(class-name class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="193"><tt><b>(class-initializers class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Accessors for class objects (look better than using '<a href="tiny-clos-doc.html#178" title="Documentation for 'swindle/slot-ref.ss'"><tt>slot-ref</tt></a>').
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="194"><tt><b>(generic-methods generic)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="195"><tt><b>(generic-arity generic)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="196"><tt><b>(generic-name generic)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="197"><tt><b>(generic-combination generic)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Accessors for generic function objects.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="198"><tt><b>(method-specializers method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="199"><tt><b>(method-procedure method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="200"><tt><b>(method-qualifier method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="201"><tt><b>(method-name method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="202"><tt><b>(method-arity method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Accessors for method objects.  '<a href="tiny-clos-doc.html#202" title="Documentation for 'swindle/method-arity.ss'"><tt>method-arity</tt></a>' is not really an
  accessor, it is deduced from the arity of the procedure (minus one for
  the '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' argument).
</pre>
<h3>Basic classes</h3>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="204"><tt><b><tt>&lt;class&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  This is the &quot;mother of all classes&quot;: every Swindle class is an
  instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>'.
  Slots:
  * direct-supers:  direct superclasses
  * direct-slots:   direct slots, each a list of a name and options
  * cpl:            class precedence list (classes list this to &lt;top&gt;)
  * slots:          all slots (like direct slots)
  * nfields:        number of fields
  * field-initializers: a list of functions to initialize slots
  * getters-n-setters:  an alist of slot-names, getters, and setters
  * name:           class name (usually the defined identifier)
  * initializers:   procedure list that perform additional initializing
  See the '<tt>clos</tt>' documentation for available class and slot keyword
  arguments and their effect.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#205" title="Documentation for 'swindle/<object>.ss'"><tt>&lt;object&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="206"><tt><b><tt>&lt;top&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  This is the &quot;mother of all values&quot;: every value is an instance of
  '<a href="tiny-clos-doc.html#206" title="Documentation for 'swindle/<top>.ss'"><tt>&lt;top&gt;</tt></a>' (including standard Scheme values).
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="205"><tt><b><tt>&lt;object&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  This is the &quot;mother of all objects&quot;: every Swindle object is an
  instance of '<a href="tiny-clos-doc.html#205" title="Documentation for 'swindle/<object>.ss'"><tt>&lt;object&gt;</tt></a>'.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#206" title="Documentation for 'swindle/<top>.ss'"><tt>&lt;top&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="207"><tt><b><tt>&lt;procedure-class&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of all procedures classes, both standard Scheme procedures
  classes and entity (Swindle procedure objects) classes.  (Note that
  this is a class of *classes*).
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="208"><tt><b><tt>&lt;entity-class&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of entity classes -- generic functions and methods.  An
  entity is a procedural Swindle object, something that you can apply as
  a function but it is still a Swindle object.  Note that this is the
  class of entity *classes* not of entities themselves.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#207" title="Documentation for 'swindle/<procedure-class>.ss'"><tt>&lt;procedure-class&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="209"><tt><b><tt>&lt;function&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of all applicable values: methods, generic functions, and
  standard closures.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#206" title="Documentation for 'swindle/<top>.ss'"><tt>&lt;top&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="210"><tt><b><tt>&lt;generic&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of generic functions: objects that contain method objects
  and calls the appropriate ones when applied.
  Slots:
  * methods:     a list of &lt;method&gt; objects
  * arity:       the generic arity (same for all of its methods)
  * name:        generic name
  * combination: a method combination function or #f, see
                 '<a href="tiny-clos-doc.html#211" title="Documentation for 'swindle/make-generic-combination.ss'"><tt>make-generic-combination</tt></a>' below for details
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#208" title="Documentation for 'swindle/<entity-class>.ss'"><tt>&lt;entity-class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#205" title="Documentation for 'swindle/<object>.ss'"><tt>&lt;object&gt;</tt></a>', '<a href="tiny-clos-doc.html#209" title="Documentation for 'swindle/<function>.ss'"><tt>&lt;function&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="212"><tt><b><tt>&lt;method&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of methods: objects that are similar to Scheme closures,
  except that they have type specifiers attached.  Note that in contrast
  to Tiny CLOS, methods are applicable objects in Swindle -- they check
  supplied argument types when applied.
  Slots:
  * specializers: a list of class (and singleton) specializers
  * procedure:    the function (never call directly!)
  * qualifier:    some qualifier tag, used when applying a generic
  * name:         method name
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#208" title="Documentation for 'swindle/<entity-class>.ss'"><tt>&lt;entity-class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#205" title="Documentation for 'swindle/<object>.ss'"><tt>&lt;object&gt;</tt></a>', '<a href="tiny-clos-doc.html#209" title="Documentation for 'swindle/<function>.ss'"><tt>&lt;function&gt;</tt></a>'.
</pre>
<h3>Convenience functions</h3>
<pre>
These are some convenience functions -- no new syntax, just function
wrappers for '<a href="tiny-clos-doc.html#213" title="Documentation for 'swindle/make.ss'"><tt>make</tt></a>' with some class and some slot values.  See '<tt>clos</tt>'
for a more sophisticated (and convenient) approach.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="214"><tt><b>(make-class direct-supers direct slots)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Creates a class object -- an instance of &lt;class&gt;.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="215"><tt><b>(make-generic-function [name/arity])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Creates a generic function object -- an instance of &lt;generic&gt;.  The
  argument can specify name and/or arguments number.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="216"><tt><b>(make-method specializers procedure)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Creates a method object -- an instance of &lt;method&gt;, using the given
  specializer list and procedure.  The procedure should have a first
  argument which is being used to access a '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' call.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="217"><tt><b>(no-next-method generic method [args ...])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
  <tr>
    <td><a name="218"><tt><b>(no-applicable-method generic [args ...])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  These two generic functions are equivalents to the ones in CL.  The
  first one is applied on a generic and a method in case there was no
  next method and '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' was used.  The second is used when
  a generic was called but no matching primary methods were found.  The
  only difference is that in Swindle methods can be applied directly,
  and if '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' is used, then '<a href="tiny-clos-doc.html#217" title="Documentation for 'swindle/no-next-method.ss'"><tt>no-next-method</tt></a>' gets '<tt>#f</tt>' for
  the generic argument.
</pre>
<hr>
<a name="219"><h2>Generics in the instance initialization protocol</h2></a>
<pre>The following generic functions are used as part of the protocol of
instantiating an instance, and some are used specifically to instantiate
class objects.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="220"><tt><b>(allocate-instance class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic function is called to allocate an instance of a class.
  It is applied on the class object, and is expected to return the new
  instance object of that class.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="221"><tt><b>(initialize instance initargs)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic is called to initialize an instance.  It is applied on
  the newly allocated object and the given initargs, and is not expected
  to return any meaningful value -- only do some side effects on the
  instance to initialize it.  When overriding this for a some class, it
  is not a good idea to skip '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' since it is responsible
  for initializing slot values.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="222"><tt><b>(compute-getter-and-setter class slot allocator)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic is used to get a getter and setter functions for a given
  slot.  It is passed the class object, the slot information (a list of
  a slot name and options), and an allocator function.  The allocator is
  a function that gets an initializer function and returns an index
  position for the new slot.  The return value should be a list of two
  elements -- a getter and a setter functions.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="223"><tt><b>(compute-cpl class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic is used to get the class-precedence-list for a class
  object.  The standard &lt;class&gt; object uses the '<tt>compute-std-cpl</tt>' (see
  in the code) which flattens the class ancestors using a topological
  sort that resolve ambiguities left-to-right.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="224"><tt><b>(compute-slots class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic is used to compute all slot information for a given
  class, after its precedence list has been computed.  The standard
  &lt;class&gt; collects information from all preceding classes.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="225"><tt><b>(compute-apply-method method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic is used to compute the procedure that will get executed
  when a method is applied directly.
</pre>
<hr>
<a name="226"><h2>Generics in the generic invocation protocol</h2></a>
<pre>These generics are used for invocation of generic functions.  See the
code to see how this circularity is achieved.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="227"><tt><b>((compute-apply-generic generic) args ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic is used to compute the object (a closure) that is
  actually applied to execute the generic call.  The standard version
  uses '<tt>compute-method</tt>' and '<a href="tiny-clos-doc.html#228" title="Documentation for 'swindle/compute-apply-methods.ss'"><tt>compute-apply-methods</tt></a>' below, and caches
  the result.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="229"><tt><b>(compute-methods generic args)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  Computes the methods that should be applied for this generic
  invocation with args.  The standard code filters applicable methods
  and sorts them according to their specificness.  The return value is
  expected to depend only on the types of the arguments (and values if
  there are singleton specializers).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="230"><tt><b>((compute-method-more-specific? generic) mthd1 mthd2 args)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  Get a generic and return a function that gets two methods and a list
  of arguments and decide which of the two methods is more specific.
  This decision should only be based on the argument types, or values
  only in case of singletons.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="228"><tt><b>((compute-apply-methods generic methods) args ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  Gets a generic and returns a function that gets the given arguments
  for this call.  This function which it returns is the combination of
  all given methods.  The standard one arranges them by default using
  the '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' argument that methods have.  Swindle extends
  this with qualified methods and applies '<tt>before</tt>', '<tt>after</tt>', and
  '<tt>around</tt>' methods in a similar way to CLOS: first the '<tt>around</tt>' methods
  are applied (and they usually call their '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' to
  continue but can return a different value), then all the '<tt>before</tt>'
  methods are applied (with no '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>'), then all '<tt>primary</tt>'
  methods as usual (remembering the return value), and finally the
  '<tt>after</tt>' methods (similar to the '<tt>before</tt>', but in reverse specificness
  order).  If the generic has a '<tt>combination</tt>' slot value, then it is a
  procedure that is used to combine the primary methods, but the
  auxiliary ones are still applied in the same way.  This is unlike CLOS
  where the standard combinations run only '<tt>around</tt>' methods, and there
  is generally more control with method combinations, but in Swindle
  '<a href="tiny-clos-doc.html#228" title="Documentation for 'swindle/compute-apply-methods.ss'"><tt>compute-apply-methods</tt></a>' should be overridden for this.  See
  '<a href="tiny-clos-doc.html#211" title="Documentation for 'swindle/make-generic-combination.ss'"><tt>make-generic-combination</tt></a>' for details about method combinations.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="231"><tt><b>(add-method generic method)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  This generic function is called to add a method to a generic function
  object.  This is an other change from the original Tiny CLOS where it
  was a normal function.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="211"><tt><b>(((make-generic-combination keys...) generic) tail args)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  This function can be used to construct simple method combinations that
  can be used with the '<tt>combination</tt>' slot of generic functions.  The
  combination itself is a function that gets a generic and returns a
  function that gets a list of method/procedure pairs (for optimization
  the method-procedures are pre taken) and the arguments and performs
  the call -- but this is only interesting if there's any need to
  implement a method combination directly, otherwise, the
  '<a href="tiny-clos-doc.html#211" title="Documentation for 'swindle/make-generic-combination.ss'"><tt>make-generic-combination</tt></a>' interface should allow enough freedom.
  Note that when a method combination is used, '<tt>around</tt>', '<tt>before</tt>', and
  '<tt>after</tt>' are called around the primary call as usual, but the primaries
  are never called with a valid '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' argument.

  The keyword arguments that can be taken determine the behavior of this
  combination.  Overall, it is roughly like a customizable version of a
  fold operation on the method calls.
  * :init
    - The initial value for this computation.  Defaults to null.
  * :combine
    - A function to be called on a method call result and the old value,
      and produces a new value.  The default is '<tt>cons</tt>', which with an
      initial null value will collect the results into a reversed list.
  * :process-methods
    - A function that can be called on the initial list of
      method/procedure pairs to change it -- for example, it can be
      reversed to apply the methods from the least specific to the most
      specific.  No default.
  * :process-result
    - A function that can be called on the final resulting value to
      produce the actual return value.  For example, it can reverse back
      a list of accumulated values.  No default.
  * :control
    - If this parameter is specified, then the '<tt>:combine</tt>' argument is
      ignored.  The value given to '<tt>:control</tt>' should be a function of
      four arguments:
      1. a '<tt>loop</tt>' function that should be called on some new value and
         some new tail;
      2. a '<tt>val</tt>' argument that gets the current accumulated value;
      3. a '<tt>this</tt>' thunk that can be called to apply the current method
         and return its result;
      4. a '<a href="misc-doc.html#93" title="Documentation for 'swindle/tail.ss'"><tt>tail</tt></a>' value that holds the rest of the method/procedure list
         which can be sent to '<tt>loop</tt>'.
      It should be clear now, that a '<tt>:control</tt>' argument can have a lot
      of control on the computation, it can abort, change arbitrary
      values and skip calling methods.  Note that if it won't call
      '<tt>loop</tt>' with an empty list, then a '<tt>:process-result</tt>' function will
      not be used as well.  See the pre-defined combinations in the
      source code to see examples of using this function.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="232"><tt><b>generic-+-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="233"><tt><b>generic-list-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="234"><tt><b>generic-min-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="235"><tt><b>generic-max-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="236"><tt><b>generic-append-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="237"><tt><b>generic-append!-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="238"><tt><b>generic-begin-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="239"><tt><b>generic-and-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="240"><tt><b>generic-or-combination</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  These are all functions that can be used as a '<tt>combination</tt>' value for
  a generic function.  They work in the same way as the standard method
  combinations of CL.  Most of them do the obvious thing based on some
  function to combine the result.  The '<tt>begin</tt>' combination simply
  executes all methods one by one and returns the last value, the '<tt>and</tt>'
  and '<tt>or</tt>' combinations will call them one by one until a false or true
  result is returned.  The source of these can be used as templates for
  defining more combinations.
</pre>
<h3>More class functionality</h3>
<pre>(In the following, a '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>' can be a class, a singleton specifier, or a
struct type.)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="242"><tt><b>(subclass? class1 class2)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Is '<tt>class1</tt>' a subclass of '<tt>class2</tt>'?
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="243"><tt><b>(instance-of? x class)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Checks if '<tt>x</tt>' is an instance of '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>' (or one of its subclasses).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="244"><tt><b>(class? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Determines whether '<tt>x</tt>' is a class.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="245"><tt><b>(specializer? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Determines whether '<tt>x</tt>' is a class, a singleton, or a struct-type.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="246"><tt><b>(more-specific? class1 class2 x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Is '<tt>class1</tt>' more specific than '<tt>class2</tt>' for the given value?
</pre>
<hr>
<a name="247"><h2>Swindle Customization Parameters</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="248"><tt><b>*default-method-class*</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[parameter]</td>
  </tr>
  <tr>
    <td><a name="249"><tt><b>*default-generic-class*</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[parameter]</td>
  </tr>
  <tr>
    <td><a name="250"><tt><b>*default-class-class*</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[parameter]</td>
  </tr>
  <tr>
    <td><a name="251"><tt><b>*default-entityclass-class*</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[parameter]</td>
  </tr>
</table>
<pre>  These parameters specify default classes for the many constructor
  macros in '<tt>clos</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="252"><tt><b>*default-object-class*</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[parameter]</td>
  </tr>
</table>
<pre>  This parameter contains a value which is automatically made a
  superclass for all classes.  Defaults to '<a href="tiny-clos-doc.html#205" title="Documentation for 'swindle/<object>.ss'"><tt>&lt;object&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="253"><tt><b>*make-safely*</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[parameter]</td>
  </tr>
</table>
<pre>  Setting this parameter to #t will make Swindle perform sanity checks
  on given initargs for creating an object.  This will make things
  easier for debugging, but also slower.  Defaults to '<tt>#f</tt>'.  Note that
  the sanity checks are done in '<a href="tiny-clos-doc.html#221" title="Documentation for 'swindle/initialize.ss'"><tt>initialize</tt></a>'.
</pre>
<hr>
<a name="254"><h2>Creating Instances</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="213"><tt><b>(make class initargs ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[generic]</td>
  </tr>
</table>
<pre>  Create an instance of '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>', which can be any Swindle class (except
  for some special top-level classes and built-in classes).

  See the `Object Initialization Protocol' below for a description of
  generic functions that are involved in creating a Swindle object.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="255"><tt><b>(rec-make (name class arg ...) ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  This is similar to:

    (letrec ([name (make class arg ...)] ...)
      (values name ...))

  except that the names are first bound to allocated instances with no
  initargs, and then they are initialized with all these bindings.  This
  is useful for situations where creating some instances needs other
  instances as values.  One sample usage is the way '<a href="clos-doc.html#256" title="Documentation for 'swindle/defclass.ss'"><tt>defclass</tt></a>' makes the
  class binding available for slot specifications like '<tt>:type</tt>'.  Note
  that this is a special form, which invokes '<a href="tiny-clos-doc.html#220" title="Documentation for 'swindle/allocate-instance.ss'"><tt>allocate-instance</tt></a>' and
  '<a href="tiny-clos-doc.html#221" title="Documentation for 'swindle/initialize.ss'"><tt>initialize</tt></a>' directly, so specializing '<a href="tiny-clos-doc.html#213" title="Documentation for 'swindle/make.ss'"><tt>make</tt></a>' on some input will not
  change the way '<a href="tiny-clos-doc.html#255" title="Documentation for 'swindle/rec-make.ss'"><tt>rec-make</tt></a>' works.
</pre>
<hr>
<a name="257"><h2>Built-in Classes</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="258"><tt><b><tt>&lt;primitive-class&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of all built-on classes.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="259"><tt><b><tt>&lt;builtin&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The superclass of all built-in classes.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#204" title="Documentation for 'swindle/<class>.ss'"><tt>&lt;class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#206" title="Documentation for 'swindle/<top>.ss'"><tt>&lt;top&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="260"><tt><b><tt>&lt;sequence&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  Instance of '<a href="tiny-clos-doc.html#258" title="Documentation for 'swindle/<primitive-class>.ss'"><tt>&lt;primitive-class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#259" title="Documentation for 'swindle/<builtin>.ss'"><tt>&lt;builtin&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="261"><tt><b><tt>&lt;immutable&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="262"><tt><b><tt>&lt;improper-list&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="263"><tt><b><tt>&lt;pair&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="264"><tt><b><tt>&lt;immutable-pair&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="265"><tt><b><tt>&lt;list&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="266"><tt><b><tt>&lt;nonempty-list&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="267"><tt><b><tt>&lt;immutable-nonempty-list&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="268"><tt><b><tt>&lt;null&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="269"><tt><b><tt>&lt;vector&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="270"><tt><b><tt>&lt;char&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="271"><tt><b><tt>&lt;string&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="272"><tt><b><tt>&lt;immutable-string&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="273"><tt><b><tt>&lt;symbol&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="274"><tt><b><tt>&lt;boolean&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="275"><tt><b><tt>&lt;number&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="276"><tt><b><tt>&lt;exact&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="277"><tt><b><tt>&lt;inexact&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="278"><tt><b><tt>&lt;complex&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="279"><tt><b><tt>&lt;real&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="280"><tt><b><tt>&lt;rational&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="281"><tt><b><tt>&lt;integer&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="282"><tt><b><tt>&lt;exact-complex&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="283"><tt><b><tt>&lt;inexact-complex&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="284"><tt><b><tt>&lt;exact-real&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="285"><tt><b><tt>&lt;inexact-real&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="286"><tt><b><tt>&lt;exact-rational&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="287"><tt><b><tt>&lt;inexact-rational&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="288"><tt><b><tt>&lt;exact-integer&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="289"><tt><b><tt>&lt;inexact-integer&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="290"><tt><b><tt>&lt;end-of-file&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="291"><tt><b><tt>&lt;port&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="292"><tt><b><tt>&lt;input-port&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="293"><tt><b><tt>&lt;output-port&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="294"><tt><b><tt>&lt;stream-port&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="295"><tt><b><tt>&lt;input-stream-port&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="296"><tt><b><tt>&lt;output-stream-port&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="297"><tt><b><tt>&lt;void&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="298"><tt><b><tt>&lt;box&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="299"><tt><b><tt>&lt;weak-box&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="300"><tt><b><tt>&lt;regexp&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="301"><tt><b><tt>&lt;parameter&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="302"><tt><b><tt>&lt;promise&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="303"><tt><b><tt>&lt;exn&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="304"><tt><b><tt>&lt;break-exn&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="305"><tt><b><tt>&lt;non-break-exn&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="306"><tt><b><tt>&lt;semaphore&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="307"><tt><b><tt>&lt;hash-table&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="308"><tt><b><tt>&lt;subprocess&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="309"><tt><b><tt>&lt;thread&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="310"><tt><b><tt>&lt;syntax&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="311"><tt><b><tt>&lt;identifier-syntax&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="312"><tt><b><tt>&lt;namespace&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="313"><tt><b><tt>&lt;custodian&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="314"><tt><b><tt>&lt;tcp-listener&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="315"><tt><b><tt>&lt;security-guard&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="316"><tt><b><tt>&lt;will-executor&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="317"><tt><b><tt>&lt;struct-type&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="318"><tt><b><tt>&lt;inspector&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="319"><tt><b><tt>&lt;pseudo-random-generator&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="320"><tt><b><tt>&lt;compiled-expression&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
  <tr>
    <td><a name="321"><tt><b><tt>&lt;unknown-primitive&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  These classes represent built-in objects.  See the class hierarchy
  below for a complete description of the relations between these
  classes.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="187"><tt><b><tt>&lt;struct&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  Instance of '<a href="tiny-clos-doc.html#258" title="Documentation for 'swindle/<primitive-class>.ss'"><tt>&lt;primitive-class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#259" title="Documentation for 'swindle/<builtin>.ss'"><tt>&lt;builtin&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="322"><tt><b><tt>&lt;opaque-struct&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  These are also classes for built-in objects, but they are classes for
  MzScheme structs -- which can be used like Swindle classes since they
  will get converted to appropriate Swindle subclasses of '<a href="tiny-clos-doc.html#187" title="Documentation for 'swindle/<struct>.ss'"><tt>&lt;struct&gt;</tt></a>'.
  '<a href="tiny-clos-doc.html#322" title="Documentation for 'swindle/<opaque-struct>.ss'"><tt>&lt;opaque-struct&gt;</tt></a>' is a class of structs that are hidden -- see the
  documentation for '<tt>struct-info</tt>' and the '<tt>skipped?</tt>' result.  Note that
  structs can be used as long as they can be inspected -- otherwise, we
  can't even know that they are structs with '<tt>struct?</tt>' (this means that
  &lt;opaque-struct&gt; can only appear in the cpl of a struct class that
  inherits from a struct which is not under the current inspector).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="323"><tt><b><tt>&lt;procedure&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of all Scheme procedures.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#207" title="Documentation for 'swindle/<procedure-class>.ss'"><tt>&lt;procedure-class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#259" title="Documentation for 'swindle/<builtin>.ss'"><tt>&lt;builtin&gt;</tt></a>', '<a href="tiny-clos-doc.html#209" title="Documentation for 'swindle/<function>.ss'"><tt>&lt;function&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="324"><tt><b><tt>&lt;primitive-procedure&gt;</tt></b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[class]</td>
  </tr>
</table>
<pre>  The class of all primitive MzScheme procedures.
</pre>
<pre>  Instance of '<a href="tiny-clos-doc.html#207" title="Documentation for 'swindle/<procedure-class>.ss'"><tt>&lt;procedure-class&gt;</tt></a>', subclass of '<a href="tiny-clos-doc.html#323" title="Documentation for 'swindle/<procedure>.ss'"><tt>&lt;procedure&gt;</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="325"><tt><b>(builtin? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="326"><tt><b>(function? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="327"><tt><b>(generic? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="328"><tt><b>(method? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Predicates for instances of &lt;builtin&gt;, &lt;function&gt;, &lt;generic&gt;, and
  &lt;method&gt;.
</pre>
<hr>
<a name="329"><h2>Class Hierarchy</h2></a>
<pre>In the following, every class's class is specified after a colon.  Also,
some classes appear in more than once place due to multiple-inheritance.

  &lt;top&gt; : &lt;class&gt;
    &lt;object&gt; : &lt;class&gt;
      &lt;class&gt; : &lt;class&gt;
        &lt;procedure-class&gt; : &lt;class&gt;
          &lt;entity-class&gt; : &lt;class&gt;
        &lt;primitive-class&gt; : &lt;class&gt;
      &lt;generic&gt; : &lt;entity-class&gt;
      &lt;method&gt; : &lt;entity-class&gt;
    &lt;function&gt; : &lt;class&gt;
      &lt;generic&gt; : &lt;entity-class&gt;
      &lt;method&gt; : &lt;entity-class&gt;
      &lt;procedure&gt; : &lt;procedure-class&gt;
        &lt;primitive-procedure&gt; : &lt;procedure-class&gt;
    &lt;builtin&gt; : &lt;class&gt;
      &lt;sequence&gt; : &lt;primitive-class&gt;
        &lt;improper-list&gt; : &lt;primitive-class&gt;
          &lt;pair&gt; : &lt;primitive-class&gt;
            &lt;immutable-pair&gt; : &lt;primitive-class&gt;
            &lt;nonempty-list&gt; : &lt;primitive-class&gt;
              &lt;immutable-nonempty-list&gt; : &lt;primitive-class&gt;
          &lt;list&gt; : &lt;primitive-class&gt;
            &lt;nonempty-list&gt; : &lt;primitive-class&gt;
              &lt;immutable-nonempty-list&gt; : &lt;primitive-class&gt;
            &lt;null&gt; : &lt;primitive-class&gt;
        &lt;vector&gt; : &lt;primitive-class&gt;
        &lt;string&gt; : &lt;primitive-class&gt;
          &lt;immutable-string&gt; : &lt;primitive-class&gt;
      &lt;immutable&gt; : &lt;primitive-class&gt;
        &lt;immutable-nonempty-list&gt; : &lt;primitive-class&gt;
        &lt;immutable-pair&gt; : &lt;primitive-class&gt;
        &lt;immutable-string&gt; : &lt;primitive-class&gt;
      &lt;char&gt; : &lt;primitive-class&gt;
      &lt;symbol&gt; : &lt;primitive-class&gt;
      &lt;boolean&gt; : &lt;primitive-class&gt;
      &lt;number&gt; : &lt;primitive-class&gt;
        &lt;complex&gt; : &lt;primitive-class&gt;
          &lt;exact-complex&gt; : &lt;primitive-class&gt;
          &lt;inexact-complex&gt; : &lt;primitive-class&gt;
          &lt;real&gt; : &lt;primitive-class&gt;
            &lt;exact-real&gt; : &lt;primitive-class&gt;
            &lt;inexact-real&gt; : &lt;primitive-class&gt;
            &lt;rational&gt; : &lt;primitive-class&gt;
              &lt;integer&gt; : &lt;primitive-class&gt;
              &lt;exact-rational&gt; : &lt;primitive-class&gt;
              &lt;inexact-rational&gt; : &lt;primitive-class&gt;
                &lt;exact-integer&gt; : &lt;primitive-class&gt;
                &lt;inexact-integer&gt; : &lt;primitive-class&gt;
        &lt;exact&gt; : &lt;primitive-class&gt;
          &lt;exact-complex&gt; : &lt;primitive-class&gt;
            &lt;exact-real&gt; : &lt;primitive-class&gt;
              &lt;exact-rational&gt; : &lt;primitive-class&gt;
                &lt;exact-integer&gt; : &lt;primitive-class&gt;
        &lt;inexact&gt; : &lt;primitive-class&gt;
          &lt;inexact-complex&gt; : &lt;primitive-class&gt;
            &lt;inexact-real&gt; : &lt;primitive-class&gt;
              &lt;inexact-rational&gt; : &lt;primitive-class&gt;
                &lt;inexact-integer&gt; : &lt;primitive-class&gt;
      &lt;end-of-file&gt; : &lt;primitive-class&gt;
      &lt;port&gt; : &lt;primitive-class&gt;
        &lt;input-port&gt; : &lt;primitive-class&gt;
          &lt;input-stream-port&gt; : &lt;primitive-class&gt;
        &lt;output-port&gt; : &lt;primitive-class&gt;
          &lt;output-stream-port&gt; : &lt;primitive-class&gt;
        &lt;stream-port&gt; : &lt;primitive-class&gt;
          &lt;input-stream-port&gt; : &lt;primitive-class&gt;
          &lt;output-stream-port&gt; : &lt;primitive-class&gt;
      &lt;void&gt; : &lt;primitive-class&gt;
      &lt;box&gt; : &lt;primitive-class&gt;
        &lt;weak-box&gt; : &lt;primitive-class&gt;
      &lt;regexp&gt; : &lt;primitive-class&gt;
      &lt;parameter&gt; : &lt;primitive-class&gt;
      &lt;promise&gt; : &lt;primitive-class&gt;
      &lt;exn&gt; : &lt;primitive-class&gt;
        &lt;break-exn&gt; : &lt;primitive-class&gt;
        &lt;non-break-exn&gt; : &lt;primitive-class&gt;
      &lt;semaphore&gt; : &lt;primitive-class&gt;
      &lt;hash-table&gt; : &lt;primitive-class&gt;
      &lt;subprocess&gt; : &lt;primitive-class&gt;
      &lt;thread&gt; : &lt;primitive-class&gt;
      &lt;syntax&gt; : &lt;primitive-class&gt;
        &lt;identifier-syntax&gt; : &lt;primitive-class&gt;
      &lt;namespace&gt; : &lt;primitive-class&gt;
      &lt;custodian&gt; : &lt;primitive-class&gt;
      &lt;tcp-listener&gt; : &lt;primitive-class&gt;
      &lt;security-guard&gt; : &lt;primitive-class&gt;
      &lt;will-executor&gt; : &lt;primitive-class&gt;
      &lt;inspector&gt; : &lt;primitive-class&gt;
      &lt;pseudo-random-generator&gt; : &lt;primitive-class&gt;
      &lt;compiled-expression&gt; : &lt;primitive-class&gt;
      &lt;unknown-primitive&gt; : &lt;primitive-class&gt;
      &lt;procedure&gt; : &lt;procedure-class&gt;
        &lt;primitive-procedure&gt; : &lt;procedure-class&gt;
      &lt;struct&gt; : &lt;primitive-class&gt;
        &lt;opaque-struct&gt; : &lt;primitive-class&gt;
        ... struct type classes ...
</pre>
<hr>
<a name="330"><h2>Object Initialization Protocol</h2></a>
<pre>This is the initialization protocol.  All of these are generic
functions (unlike the original Tiny CLOS).  See the individual
descriptions above for more details.

  make
    allocate-instance
    initialize
  class initialization only:
    compute-cpl
    compute-slots
    compute-getter-and-setter
  method initialization only:
    compute-apply-method
  add-method
    compute-apply-generic
      compute-methods
        compute-method-more-specific?
      compute-apply-methods
</pre>
</body>
</html>
<!-- Generated by Swindle/html -->
