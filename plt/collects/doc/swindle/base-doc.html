<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Generated by Swindle/html (http://www.barzilay.org/Swindle/) -->
<html>
<head>
  <title>Documentation for 'swindle/base.ss'</title>
</head>
<body bgcolor="#C0C0FF" text="#000000" link="#B00000" vlink="#600000" alink="#FF0000">
<h1 align="center">Documentation for '<tt>swindle/base.ss</tt>'</h1>
<hr>
<p>
The '<tt>base</tt>' module defines some basic low-level syntactic extensions to
MzScheme.  It can be used by itself to get these extensions.
</p>
<p>
This module is intended to be used as a language module
(as an initial-import for other modules).
</p>
<hr>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="1"><tt><b>(#%module-begin ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  '<tt>base</tt>' is a language module -- it redefines '<a href="turbo-doc.html#1" title="Documentation for 'swindle/#%module-begin.ss'"><tt>#%module-begin</tt></a>' to load
  itself for syntax definitions.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="2"><tt><b>(#%top . id)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  This special syntax is redefined to make keywords (symbols whose names
  begin with a &quot;:&quot;) evaluate to themselves.  Note that this does not
  interfere with using such symbols for local bindings.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="3"><tt><b>(#%app ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Redefined so it is possible to apply using dot notation: `(foo x . y)'
  is the same as `(apply foo x y)'.  This is possible only when the last
  (dotted) element is an identifier.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="4"><tt><b>(define id-or-list ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  The standard '<a href="base-doc.html#4" title="Documentation for 'swindle/define.ss'"><tt>define</tt></a>' form is modified so instead of an identifier
  name for a function, a list can be used -- resulting in a curried
  function.
    =&gt; (define (((plus x) y) z) (+ x y z))
    =&gt; plus
    #&lt;procedure:plus&gt;
    =&gt; (plus 5)
    #&lt;procedure:plus:1&gt;
    =&gt; ((plus 5) 6)
    #&lt;procedure:plus:2&gt;
    =&gt; (((plus 5) 6) 7)
    18
  Note the names of intermediate functions.

  In addition, the following form can be used to define multiple values:
    =&gt; (define (values a b) (values 1 2))
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="5"><tt><b>(let ([id-or-list ...] ...) ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="6"><tt><b>(let* ([id-or-list ...] ...) ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="7"><tt><b>(letrec ([id-or-list ...] ...) ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  All standard forms of '<a href="base-doc.html#5" title="Documentation for 'swindle/let.ss'"><tt>let</tt></a>' are redefined so they can generate
  functions using the same shortcut that '<a href="base-doc.html#4" title="Documentation for 'swindle/define.ss'"><tt>define</tt></a>' allows.  This includes
  the above extension to the standard '<a href="base-doc.html#4" title="Documentation for 'swindle/define.ss'"><tt>define</tt></a>'.  For example:
    =&gt; (let ([((f x) y) (+ x y)]) ((f 1) 2))
    3
  It also includes the '<tt>values</tt>' keyword in a similar way to '<a href="base-doc.html#4" title="Documentation for 'swindle/define.ss'"><tt>define</tt></a>'.
  For example:
    =&gt; (let ([(values i o) (make-pipe)]) i)
    #&lt;pipe-input-port&gt;
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="8"><tt><b>(lambda formals body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  The standard '<a href="base-doc.html#8" title="Documentation for 'swindle/lambda.ss'"><tt>lambda</tt></a>' is extended with Lisp-like &amp;-keywords in its
  argument list.  This extension is available using the above short
  syntax.  There is one important difference between these keywords and
  Lisp: some &amp;-keywords are used to access arguments that follow the
  keyword part of the arguments.  This makes it possible to write
  procedures that can be invoked as follows:
    (f &lt;required-args&gt; &lt;optional-args&gt; &lt;keyword-args&gt; &lt;additional-args&gt;)
  (Note: do not use more keywords after the &lt;additional-args&gt;!)

  Available &amp;-keywords are:
  * &amp;optional, &amp;opt, &amp;opts: denote an optional argument, possibly with a
    default value (if the variable is specified as `(var val)').
      =&gt; ((lambda (x &amp;optional y [z 3]) (list x y z)) 1)
      (1 #f 3)
      =&gt; ((lambda (x &amp;optional y [z 3]) (list x y z)) 1 2 #f)
      (1 2 #f)
  * &amp;keys, &amp;key: a keyword argument -- the variable should be specified
    as '<tt>x</tt>' or '<tt>(x)</tt>' to be initialized by an '<tt>:x</tt>' keyword, `(x v)' to
    specify a default value '<tt>v</tt>', and `(x k v)' to further specify an
    arbitrary keyword '<tt>k</tt>'.
      =&gt; ((lambda (&amp;key x [y 2] [z :zz 3]) (list x y z)) :x 'x :zz 'z)
      (x 2 z)
    Note that keyword values take precedence on the left, and that
    keywords are not verified:
      =&gt; ((lambda (&amp;key y) y) :y 1 :z 3 :y 2)
      1
  * &amp;rest: a '<tt>rest</tt>' argument which behaves exactly like the Scheme dot
    formal parameter (actually a synonym for it: can't use both).  Note
    that in case of optional arguments, the rest variable holds any
    arguments that were not used for defaults, but using keys doesn't
    change its value.  For example:
      =&gt; ((lambda (x &amp;rest r) r) 1 2 3)
      (2 3)
      =&gt; ((lambda (x &amp;optional y &amp;rest r) r) 1)
      ()
      =&gt; ((lambda (x &amp;optional y &amp;rest r) r) 1 2 3)
      (3)
      =&gt; ((lambda (x &amp;optional y . r) r) 1 2 3)
      (3)
      =&gt; ((lambda (x &amp;key y &amp;rest r) (list y r)) 1 :y 2 3 4)
      (2 (:y 2 3 4))
      =&gt; ((lambda (x &amp;key y &amp;rest r) (list y r)) 1 :y 2 3 4 5)
      (2 (:y 2 3 4 5))
    Note that the last two examples indicate that there is no error if
    the given argument list is not balanced.
  * &amp;rest-keys: similar to '<tt>&amp;rest</tt>', but all specified keys are removed
    with their values.
      =&gt; ((lambda (x &amp;key y &amp;rest r) r) 1 :x 2 :y 3)
      (:x 2 :y 3)
      =&gt; ((lambda (x &amp;key y &amp;rest-keys r) r) 1 :x 2 :y 3)
      (:x 2)
  * &amp;body: similar to '<tt>&amp;rest-keys</tt>', but all key/values are removed one
    by one until a non-key is encountered.  (Warning: this is *not* the
    same as in Common Lisp!)
      =&gt; ((lambda (x &amp;key y &amp;body r) r) 1 :x 2 :y 3)
      ()
      =&gt; ((lambda (x &amp;key y &amp;body r) r) 1 :x 2 :y 3 5 6)
      (5 6)
  * &amp;all-keys: the list of all keys+vals, without a trailing body.
      =&gt; ((lambda (&amp;keys x y &amp;all-keys r) r) :x 1 :z 2 3 4)
      (:x 1 :z 2)
  * &amp;other-keys: the list of unprocessed keys+vals, without a trailing
    body.
      =&gt; ((lambda (&amp;keys x y &amp;other-keys r) r) :x 1 :z 2 3 4)
      (:z 2)

  Finally, here is an example where all &amp;rest-like arguments are
  different:
    =&gt; ((lambda (&amp;keys x y
                 &amp;rest r
                 &amp;rest-keys rk
                 &amp;body b
                 &amp;all-keys ak
                 &amp;other-keys ok)
          (list r rk b ak ok))
        :z 1 :x 2 2 3 4)
    ((:z 1 :x 2 2 3 4) (:z 1 2 3 4) (2 3 4) (:z 1 :x 2) (:z 1))
  Note that the following invariants hold:
  * rest = (append all-keys body)
  * rest-keys = (append other-keys body)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="9"><tt><b>(keyword? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  A predicate for keyword symbols (symbols that begin with a &quot;:&quot;).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="10"><tt><b>(syntax-keyword? x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Similar to '<a href="base-doc.html#9" title="Documentation for 'swindle/keyword?.ss'"><tt>keyword?</tt></a>' but also works for an identifier (a syntax
  object) that contains a keyword.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="11"><tt><b>(getarg args keyword [not-found])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Searches the given list of arguments for a value matched with the
  given keyword.  Similar to CL's '<tt>getf</tt>', except no error checking is
  done for an unbalanced list.  In case no value is found, the optional
  default value can be used -- this can be either a thunk, a promise, or
  any other value that will be used as is.  For a repeated keyword the
  leftmost occurrence is used.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="12"><tt><b>(syntax-getarg syntax-args keyword [not-found])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Similar to '<a href="base-doc.html#11" title="Documentation for 'swindle/getarg.ss'"><tt>getarg</tt></a>' above, but the input is a syntax object of a
  keyword-value list.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="13"><tt><b>(getargs initargs keyword)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  The same as '<a href="base-doc.html#11" title="Documentation for 'swindle/getarg.ss'"><tt>getarg</tt></a>' but return the list of all key values matched --
  no need for a default value.  The result is in the same order as in
  the input.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="14"><tt><b>(keys/args args)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  The given argument list is scanned and split at the point where there
  are no more keyword-values, and the two parts are returned as two
  values.
    =&gt; (keys/args '(:a 1 :b 2 3 4 5))
    (:a 1 :b 2)
    (3 4 5)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="15"><tt><b>(filter-out-keys outs args)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  The keywords specified in the outs argument, with their matching
  values are filtered out of the second arguments.
</pre>
</body>
</html>
<!-- Generated by Swindle/html -->
