<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Generated by Swindle/html (http://www.barzilay.org/Swindle/) -->
<html>
<head>
  <title>Documentation for 'swindle/misc.ss'</title>
</head>
<body bgcolor="#C0C0FF" text="#000000" link="#B00000" vlink="#600000" alink="#FF0000">
<h1 align="center">Documentation for '<tt>swindle/misc.ss</tt>'</h1>
<hr>
<p>
A lot of miscellaneous functionality that is needed for Swindle, or
useful by itself.
</p>
<p>
This module exports bindings from: '<tt>mzlib/string</tt>', '<tt>mzlib/list</tt>', '<tt>mzlib/etc</tt>'.
</p>
<hr>
<hr>
<a name="31"><h2>Convenient syntax definitions</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="32"><tt><b>(define* ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Just like '<a href="base-doc.html#4" title="Documentation for 'swindle/define.ss'"><tt>define</tt></a>', except that the defined identifier is
  automatically '<tt>provide</tt>'d.  Doesn't work for defining values.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="33"><tt><b>(make-provide-syntax orig-def-syntax provide-def-syntax)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Creates '<tt>provide-def-syntax</tt>' as a syntax that is the same as
  '<tt>orig-def-syntax</tt>' together with an automatic '<tt>provide</tt>' form for the
  defined symbol, which should be either the first argument or the first
  identifier in a list (it does not work for recursive nesting).  The
  convention when this is used is to use a &quot;*&quot; suffix for the second
  identifier.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="34"><tt><b>(define-syntax* ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Defined as the auto-provide form of '<tt>define-syntax</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="35"><tt><b>(defsyntax ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="36"><tt><b>(defsyntax* ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="37"><tt><b>(letsyntax (local-syntaxes ...) ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These are just shorthands for '<tt>define-syntax</tt>', '<a href="misc-doc.html#34" title="Documentation for 'swindle/define-syntax*.ss'"><tt>define-syntax*</tt></a>', and
  '<tt>let-syntax</tt>'.  This naming scheme is consistent with other definitions
  in this module (and the rest of Swindle).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="38"><tt><b>(defsubst name body)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="39"><tt><b>(defsubst* name body)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="40"><tt><b>(letsubst ([name body] ...) letbody ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These are convenient ways of defining simple pattern transformer
  syntaxes (simple meaning they're much like inlined functions).  In
  each of these forms, the '<tt>name</tt>' can be either a `(name arg ...)' which
  will define a simple macro or an identifier which will define a
  symbol-macro.  For example:
    =&gt; (defsubst (my-if cond then else)
         (if (and cond (not (eq? 0 cond))) then else))
    =&gt; (my-if 1 (echo 2) (echo 3))
    2
    =&gt; (my-if 0 (echo 2) (echo 3))
    3
    =&gt; (define x (list 1 2 3))
    =&gt; (defsubst car-x (car x))
    =&gt; car-x
    1
    =&gt; (set! car-x 11)
    =&gt; x
    (11 2 3)
  Actually, if a `(name arg ...)' is used, then the body can have more
  pattern/expansions following -- but since this form translates to a
  usage of '<tt>syntax-rules</tt>', the '<tt>name</tt>' identifier should normally be '<tt>_</tt>'
  in subsequent patterns.  For example:
    =&gt; (defsubst (my-if cond then else)
                   (if (and cond (not (eq? 0 cond))) then else)
                 (_ cond then)
                   (and cond (not (eq? 0 cond)) then))
    =&gt; (my-if 0 1)
    #f
  Finally, note that since these are just patterns that get handled by
  syntax-rules, all the usual pattern stuff applies, like using '<tt>...</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="41"><tt><b>(defmacro name body)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="42"><tt><b>(defmacro* name body)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="43"><tt><b>(letmacro ([name body] ...) letbody ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These are just like MzScheme's define-macro (from mzlib/defmacro) with
  two major extensions:
  * If '<tt>name</tt>' is a simple identifier then a symbol-macro is defined (as
    with '<a href="misc-doc.html#38" title="Documentation for 'swindle/defsubst.ss'"><tt>defsubst</tt></a>' above).
  * A '<a href="misc-doc.html#43" title="Documentation for 'swindle/letmacro.ss'"><tt>letmacro</tt></a>' form for local macros is provided.
</pre>
<hr>
<a name="44"><h2>Controlling syntax</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="45"><tt><b>(define-syntax-parameter name default)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="46"><tt><b>(define-syntax-parameter* name default)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Creates a `syntax parameter'.  Syntax parameters are things that you
  can use just like normal parameters, but they are syntax transformers,
  and the information they store can be used by other syntax
  transformers.  The purpose of having them around is to parameterize
  the way syntax transformation is used -- so they should be used as
  global option changes, not for frequent side effect: they change their
  value at syntax expansion time.  Note that using it stores the literal
  syntax that is passed to them -- there is no way to evaluate the given
  argument, for example, if some parameter expects a boolean -- then
  `(not #t)' will not work!  The syntax parameter itself is invoked
  wither with no arguments to retrieve its value, or with an argument to
  set it.  Retrieving or setting the value in this way is meaningful
  only in an interactive context since using it in a function just
  expands to the current value:
    =&gt; (define-syntax-parameter -foo- 1)
    =&gt; (-foo-)
    1
    =&gt; (define (foo) (-foo-))
    =&gt; (-foo- 2)
    =&gt; (-foo-)
    2
    =&gt; (foo)
    1
</pre>
<hr>
<a name="47"><h2>Setters and more list accessors</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="48"><tt><b>(set-caar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="49"><tt><b>(set-cadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="50"><tt><b>(set-cdar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="51"><tt><b>(set-cddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="52"><tt><b>(set-caaar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="53"><tt><b>(set-caadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="54"><tt><b>(set-cadar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="55"><tt><b>(set-caddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="56"><tt><b>(set-cdaar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="57"><tt><b>(set-cdadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="58"><tt><b>(set-cddar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="59"><tt><b>(set-cdddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="60"><tt><b>(set-caaaar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="61"><tt><b>(set-caaadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="62"><tt><b>(set-caadar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="63"><tt><b>(set-caaddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="64"><tt><b>(set-cadaar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="65"><tt><b>(set-cadadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="66"><tt><b>(set-caddar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="67"><tt><b>(set-cadddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="68"><tt><b>(set-cdaaar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="69"><tt><b>(set-cdaadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="70"><tt><b>(set-cdadar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="71"><tt><b>(set-cdaddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="72"><tt><b>(set-cddaar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="73"><tt><b>(set-cddadr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="74"><tt><b>(set-cdddar! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="75"><tt><b>(set-cddddr! place x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  These are all defined so it is possible to use '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' from &quot;setf.ss&quot;
  with these standard and library-provided functions.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="76"><tt><b>(1st list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="77"><tt><b>(2nd list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="78"><tt><b>(3rd list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="79"><tt><b>(4th list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="80"><tt><b>(5th list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="81"><tt><b>(6th list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="82"><tt><b>(7th list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="83"><tt><b>(8th list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Quick list accessors -- no checking is done, which makes these
  slightly faster than the bindings provided by mzlib/list.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="84"><tt><b>(set-1st! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="85"><tt><b>(set-2nd! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="86"><tt><b>(set-3rd! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="87"><tt><b>(set-4th! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="88"><tt><b>(set-5th! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="89"><tt><b>(set-6th! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="90"><tt><b>(set-7th! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="91"><tt><b>(set-8th! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Setter functions for the above.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="92"><tt><b>(head pair)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="93"><tt><b>(tail pair)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="94"><tt><b>(set-head! pair x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="95"><tt><b>(set-tail! pair x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Synonyms for '<tt>first</tt>', '<tt>rest</tt>', '<tt>set-first!</tt>', '<tt>set-rest!</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="96"><tt><b>(set-second! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="97"><tt><b>(set-third! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="98"><tt><b>(set-fourth! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="99"><tt><b>(set-fifth! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="100"><tt><b>(set-sixth! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="101"><tt><b>(set-seventh! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="102"><tt><b>(set-eighth! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Defined to allow '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' with these mzlib/list functions.  Note that
  there is no error checking (unlike the accessor functions which are
  provided by mzlib/list).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="103"><tt><b>(nth list n)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="104"><tt><b>(nthcdr list n)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Functions for pulling out the nth element and the nth tail of a list.
  Note the argument order which is unlike the one in CL.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="105"><tt><b>(list-set! list n x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="106"><tt><b>(set-nth! list n x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  A function to set the nth element of a list, also provided as
  '<a href="misc-doc.html#106" title="Documentation for 'swindle/set-nth!.ss'"><tt>set-nth!</tt></a>' to allow using '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' with '<a href="misc-doc.html#103" title="Documentation for 'swindle/nth.ss'"><tt>nth</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="107"><tt><b>(set-list-ref! list n x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="108"><tt><b>(set-vector-ref! vector n x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="109"><tt><b>(set-string-ref! string n x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  These are defined as '<a href="misc-doc.html#105" title="Documentation for 'swindle/list-set!.ss'"><tt>list-set!</tt></a>', '<tt>vector-set!</tt>', and '<tt>string-set!</tt>', so
  the accessors can be used with '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="110"><tt><b>(last list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="111"><tt><b>(set-last! list x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Accessing a list's last element, and modifying it.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="112"><tt><b>(set-unbox! box x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Allow using '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' with '<tt>unbox</tt>'.  Note: this is an alias for
  '<tt>set-box!</tt>' which is an inconsistent name with other Scheme '<tt>set-foo!</tt>'
  functions -- the result is that you can also do `(setf! (box foo) x)'
  and bogusly get the same effect.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="113"><tt><b>(set-hash-table-get! table key [default] value)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  This is defined to be able to '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' into a '<tt>hash-table-get</tt>'
  accessor.  The form that '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>' assembles always puts the new value
  last, but it is still useful to have a default thunk which results in
  an optional argument in an unusual place (and this argument is ignored
  by this, which is why it is defined as a macro).  For example:
    =&gt; (define t (make-hash-table))
    =&gt; (inc! (hash-table-get t 'foo))
    hash-table-get: no value found for key: foo
    =&gt; (inc! (hash-table-get t 'foo (thunk 0)))
    =&gt; (hash-table-get t 'foo)
    1
</pre>
<hr>
<a name="114"><h2>Utilities</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="115"><tt><b>(eprintf fmt-string args ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Same as '<tt>printf</tt>' but it uses the current-error-port.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="116"><tt><b>concat</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  A shorter alias for '<tt>string-append</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="117"><tt><b>(symbol-append sym ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Self explanatory.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="118"><tt><b>(maptree func tree)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Applies given function to a tree made of cons cells, and return the
  results tree with the same shape.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="119"><tt><b>(map! func list ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Same as '<tt>map</tt>' -- but destructively modifies the first list to hold the
  results of applying the function.  Assumes all lists have the same
  length.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="120"><tt><b>(maptree! func tree)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Same as '<a href="misc-doc.html#118" title="Documentation for 'swindle/maptree.ss'"><tt>maptree</tt></a>' -- but destructively modifies the list to hold the
  results of applying the function.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="121"><tt><b>(mappend func list ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="122"><tt><b>(mappend! func list ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Common idiom for doing a `(map func list ...)' and appending the
  results.  '<a href="misc-doc.html#122" title="Documentation for 'swindle/mappend!.ss'"><tt>mappend!</tt></a>' uses '<tt>append!</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="123"><tt><b>(mapply func list-of-lists)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Apply the given '<tt>func</tt>' on every list in '<tt>list-of-lists</tt>' and return the
  results list.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="124"><tt><b>(negate predicate?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Returns a negated predicate function.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="125"><tt><b>(position-of x list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Finds '<tt>x</tt>' in '<tt>list</tt>' and returns its index.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="126"><tt><b>(find-if predicate? list)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Find and return an element of '<tt>list</tt>' which satisfies '<tt>predicate?</tt>', or
  #f if none found.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="127"><tt><b>(some predicate? list ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="128"><tt><b>(every predicate? list ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Similar to MzScheme's '<tt>ormap</tt>' and '<tt>andmap</tt>', except that when multiple
  lists are given, the check stops as soon as the shortest list ends.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="129"><tt><b>(regexp-quote string)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  The same as '<a href="misc-doc.html#129" title="Documentation for 'swindle/regexp-quote.ss'"><tt>regexp-quote</tt></a>' from mzlib/string, but faster.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="130"><tt><b>(with-output-to-string thunk)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Run '<a href="misc-doc.html#131" title="Documentation for 'swindle/thunk.ss'"><tt>thunk</tt></a>' collecting generated output into a string.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="132"><tt><b>(1+ x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="133"><tt><b>(1- x)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Synonyms for '<tt>add1</tt>' and '<tt>sub1</tt>'.
</pre>
<hr>
<a name="134"><h2>Multi-dimensional hash-tables</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="135"><tt><b>(make-l-hash-table)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="136"><tt><b>(l-hash-table-get table keys [failure-thunk])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="137"><tt><b>(l-hash-table-put! table keys value)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="138"><tt><b>(set-l-hash-table-get! table key [default] value)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These functions are similar to MzScheme's hash-table functions, except
  that they work with a list of keys (compared with '<tt>eq?</tt>').  If it was
  possible to use a custom equality hash-table, then then would use
  something like
    (lambda (x y) (and (= (length x) (length y)) (andmap eq? x y))).
  The implementation uses a hash-table of hash-tables, all of them weak,
  since it is supposed to be used for memoization.

  '<a href="misc-doc.html#138" title="Documentation for 'swindle/set-l-hash-table-get!.ss'"><tt>set-l-hash-table-get!</tt></a>' is defined to work with '<a href="setf-doc.html#16" title="Documentation for 'swindle/setf!.ss'"><tt>setf!</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="139"><tt><b>(memoize func)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Return a memoized version of '<tt>func</tt>'.  Note that if '<tt>func</tt>' is
  recursive, it should be arranged for it to call the memoized version
  rather then call itself directly.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="140"><tt><b>(memoize! func-name)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Changes the given function binding to a memoized version.
</pre>
<hr>
<a name="141"><h2>Generic iteration and list comprehension</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="142"><tt><b>(collect [dir] (var base expr) clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Sophisticated iteration syntax.  The iteration is specified by the
  given clauses, where '<tt>var</tt>' serves as an accumulator variable that
  collects a value beginning with '<tt>base</tt>' and continuing with '<tt>expr</tt>' --
  similar to a single binding in a '<tt>do</tt>' form with a variable, an initial
  value and an update expression.  But there are much more iteration
  options than a '<tt>do</tt>' form: this form supports a generic
  list-comprehension and related constructs.  Forms that use this
  construct are:
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="143"><tt><b>(loop-for clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Use when no value collection is needed, and the default for
  expressions is to do them instead of using them as a filter.
  Implemented as:
    (collect =&gt; (acc (void) acc) do clause ...)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="144"><tt><b>(list-of expr clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Implemented as:
    (reverse! (collect (acc '() (cons expr acc)) clause ...))
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="145"><tt><b>(sum-of expr clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Implemented as:
    (collect (acc 0 (+ expr acc)) clause ...)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="146"><tt><b>(product-of expr clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Implemented as:
    (collect (acc 1 (* expr acc)) clause ...)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="147"><tt><b>(count-of clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Only count matching cases, implemented as:
    (sum-of 1 clause ...)

  Each clause is either:
  * (v &lt;- ...):     a binding generator clause;
  * (v &lt;- ... and v &lt;- ...): parallel generator clauses;
  * (v is is-expr): bind '<tt>v</tt>' to the result of '<tt>is-expr</tt>';
  * while expr:     a '<a href="misc-doc.html#148" title="Documentation for 'swindle/while.ss'"><tt>while</tt></a>' keyword followed by an expression will
                    abort the whole loop if that expression evaluates to
                    #f;
  * until expr:     an '<a href="misc-doc.html#149" title="Documentation for 'swindle/until.ss'"><tt>until</tt></a>' keyword followed by an expression will
                    abort the whole loop if that expression evaluates to
                    a non-#f value;
  * when ...:       filter by the following expressions -- if an
                    expression evaluates to #f, stop processing this
                    iteration (default for all macros except for
                    '<a href="misc-doc.html#143" title="Documentation for 'swindle/loop-for.ss'"><tt>loop-for</tt></a>');
  * unless ...:     filter by the negation of the following expressions;
  * do ...:         execute the following expressions, used for side
                    effects (default for the '<a href="misc-doc.html#143" title="Documentation for 'swindle/loop-for.ss'"><tt>loop-for</tt></a>' macro);
  * expr:           expression is used according to the current mode set
                    by a '<tt>when</tt>', '<tt>unless</tt>', or '<tt>do</tt>', keyword that
                    precedes it.
  The effect of this form is to iterate each generator variable
  according to generating '<tt>&lt;-</tt>' clauses (see below for these) and
  parallel clauses, and evaluate the '<tt>expr</tt>' with each combination, which
  composes a result out of iteration-bound values and an accumulated
  result.  Generation is done in a nested fashion, where the rightmost
  generator spin fastest.  Parallel generators (specified with an infix
  '<tt>and</tt>') make all iterations happen simultaneously, ending as soon as
  the first one ends.  An '<tt>is</tt>' clause is used for binding arbitrary
  variables, a '<tt>do</tt>' clause is used to execute code for general
  side-effects, and other clauses are used to filter results before
  continuing down the clause list.  Each clause can use variables bound
  by previous clauses, and the '<tt>expr</tt>' can use all bound variables as
  well as the given accumulator variable.

  An optional first token can be used to specify the direction which is
  used to accumulate the result.  It can be one of these two tokens:
  '<tt>&lt;=</tt>': A &quot;backward&quot; collection, the default (similar to '<tt>foldl</tt>');
  '<tt>=&gt;</tt>': A &quot;forward&quot; collection (similar to '<tt>foldr</tt>').
  The default &quot;backward&quot; direction works by generating an accumulator
  carrying loop, as in this code (this code is for demonstration, not
  what '<a href="misc-doc.html#142" title="Documentation for 'swindle/collect.ss'"><tt>collect</tt></a>' creates):
    (let loop ([x foo] [acc '()])
      (if (done? x) acc (loop (next x) (cons (value x) acc))))
  which is a common Scheme idiom for such operations.  The problem is
  that this accumulation happens in reverse -- requiring reversing the
  final result (which is done by the '<a href="misc-doc.html#144" title="Documentation for 'swindle/list-of.ss'"><tt>list-of</tt></a>' macro).  A &quot;forward&quot;
  direction does a naive recursive loop:
    (let loop ([x foo])
      (if (done? x) '() (cons (value x) (loop (next x)))))
  collecting values in the correct order, but the problem is that it
  keeps a computation context which makes memory consumption
  inefficient.  The default style is usually preferred, since reversing
  a list is a cheap operation, but it is not possible when infinite
  lists (streams) are used since it is impossible to reverse them.  In
  these cases, the &quot;forward&quot; style should be used, but the '<tt>expr</tt>' must
  take care not to evaluate the iteration &quot;variable&quot; immediately, using
  '<tt>delay</tt>' or a similar mechanism (this &quot;variable&quot; is not bound to a
  value but substituted with an expression (a symbol macro)).  For
  example, here's a quick lazy list usage:
    =&gt; (defsubst (lcons x y) (delay (cons x y)))
    =&gt; (define (lcar s) (car (force s)))
    =&gt; (define (lcdr s) (cdr (force s)))
    =&gt; (define x (collect (_ '() (lcons x _)) (x &lt;- 0 ..)))
    ; loops indefinitely
    =&gt; (define x (collect =&gt; (_ '() (lcons x _)) (x &lt;- 0 ..)))
    =&gt; (lcar (lcdr (lcdr x)))
    2
  Note that the '<a href="misc-doc.html#143" title="Documentation for 'swindle/loop-for.ss'"><tt>loop-for</tt></a>' macro uses a &quot;forward&quot; direction, but this is
  only because it is slightly faster since it doesn't require an extra
  binding.
  [The direction can be changed for a single part by using a &quot;&lt;-!&quot;
  keyword instead of &quot;&lt;-&quot;, but this is an experimental feature since I
  don't know if it's actually useful for anything.  Do not try to mix
  this with the '<a href="misc-doc.html#148" title="Documentation for 'swindle/while.ss'"><tt>while</tt></a>' and '<a href="misc-doc.html#149" title="Documentation for 'swindle/until.ss'"><tt>until</tt></a>' keywords which are implemented
  differently based on the direction.]

  Generator forms are one of the following (&quot;..&quot;, &quot;then&quot;, &quot;until&quot;,
  &quot;while&quot; are literal tokens), see below for what values are generated:
  * (v &lt;- sequence):
    iterate '<tt>v</tt>' on values from '<tt>sequence</tt>';
  * (v &lt;- 1st [2nd] .. [last]):
    iterate on an enumerated range, including last element of range;
  * (v &lt;- 1st [2nd] ..&lt; last):
    iterate on an enumerated range, excluding last element of range;
  * (v &lt;- 1st [2nd] .. while last):
    iterate on an enumerated range, excluding last element of range;
  * (v &lt;- 1st [2nd] .. until last):
    iterate on an enumerated range, excluding last element of range;
  * (v &lt;- x then next-e [{while|until} cond-e]):
    start with the '<tt>x</tt>' expression, continue with the '<tt>next-e</tt>' expression
    (which can use '<tt>v</tt>'), do this while/until '<tt>cond-e</tt>' is true if a
    condition is given;
  * (v &lt;- x {while|until} cond-e):
    repeat using the '<tt>x</tt>' expression while/until '<tt>cond-e</tt>' is true;
  * (v &lt;- func arg ...):
    applies '<tt>func</tt>' to `arg ...', the result is expected to be some
    &quot;iterator value&quot; which is used to do the iteration -- iteration
    values are created by '<a href="misc-doc.html#151" title="Documentation for 'swindle/collect-iterator.ss'"><tt>collect-iterator</tt></a>' and '<a href="misc-doc.html#150" title="Documentation for 'swindle/collect-numerator.ss'"><tt>collect-numerator</tt></a>',
    see below for their description and return values.
  * (v &lt;- gen1 &lt;- gen2 &lt;- ...):
    generator clauses can have multiple parts specified by more '<tt>&lt;-</tt>'s,
    all of them will run sequentially;
  * (v1 &lt;- gen1 ... and v2 &lt;- gen2 ...):
    finally, an infix '<tt>and</tt>' specifies parallel generators, binding
    several variables.

  Iteration is possible on one of the following sequence values:
  * list: iterate over the list's element;
  * vector: iterate over the vector's elements;
  * string: iterate over characters in the string;
  * integer n: iterate on values from 0 to n-1;
  * procedure f:
    - if f accepts zero arguments, begin with (f) and iterate by
      re-applying (f) over and over, so the only way to end this
      iteration is by returning '<a href="misc-doc.html#152" title="Documentation for 'swindle/collect-final.ss'"><tt>collect-final</tt></a>' (see below);
    - otherwise, if f accepts one argument, it is taken as a generator
      function: it is passed a one-argument procedure '<tt>yield</tt>' which can
      be used to suspend its execution returning the given value, and it
      will be continued when more values are required (see
      '<a href="misc-doc.html#153" title="Documentation for 'swindle/function-iterator.ss'"><tt>function-iterator</tt></a>' below);
  * hash-table: iterate over key-value pairs -- this is done with a
    generator function:
      (lambda (yield)
        (hash-table-for-each seq (lambda (k v) (yield (cons k v)))))
  * other values: repeated infinitely.
  Note that iteration over non-lists is done efficiently, iterating over
  a vector '<tt>v</tt>' is better than iterating over `(vector-&gt;list v)'.

  Enumeration is used whenever a &quot;..&quot; token is used to specify a range.
  There are different enumeration types based on different input types,
  and all are modified by the token used:
  * &quot;..&quot;: a normal inclusive range;
  * &quot;..&lt;&quot;: a range that does not include the last element;
  * &quot;.. while&quot;: a range that continues while a predicate is true;
  * &quot;.. until&quot;: a range that continues until a predicate is true.
  The &quot;..&lt;&quot; token extends to predicates in the expected way: the element
  that satisfies the predicate is the last one and it is not included in
  the enumeration -- unlike &quot;..&quot;.
  These are the possible types that can be used with an enumeration:
  * num1 [num2] .. [num3]: go from num1 to num3 in num3 in num2-num1
    steps, if num2 is not given then use +1/-1 steps, if num3 is not
    given don't stop;
  * num1 [num2] .. pred: go from num1 by num2-num1 steps (defaults to
    1), up to the number that satisfies the given predicate;
  * char1 [char2] .. [char3/pred]: the same as with numbers, but on
    character ranges;
  * func .. [pred/x]: use '<tt>func</tt>' the same way as in an iterator above,
    use '<tt>pred</tt>' to identify the last element, if '<tt>pred</tt>' is omitted repeat
    indefinitely;
  * fst [next] .. [pred]: start with '<tt>fst</tt>', continue by repeated
    applications of the '<tt>next</tt>' function on it, and use '<tt>pred</tt>' to
    identify the last element, if '<tt>pred</tt>' is omitted repeat indefinitely,
    if '<tt>next</tt>' is omitted repeat '<tt>fst</tt>', and if both '<tt>fst</tt>' and '<tt>next</tt>' are
    numbers or characters then use their difference for stepping.  (Note
    that to repeat a function value you should use '<tt>identity</tt>' as for
    '<tt>next</tt>' or the function will be used as described above.)

  Here is a long list of examples for clarification, all using
  '<a href="misc-doc.html#144" title="Documentation for 'swindle/list-of.ss'"><tt>list-of</tt></a>', but the generalization should be obvious:
    =&gt; (list-of x [x &lt;- '(1 2 3)])
    (1 2 3)
    =&gt; (list-of (list x y) [x &lt;- '(1 2 3)] [y &lt;- 1 .. 2])
    ((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))
    =&gt; (list-of (format &quot;~a~a~a&quot; x y z)
                [x &lt;- '(1 2)] [y &lt;- #(a b)] [z &lt;- &quot;xy&quot;])
    (&quot;1ax&quot; &quot;1ay&quot; &quot;1bx&quot; &quot;1by&quot; &quot;2ax&quot; &quot;2ay&quot; &quot;2bx&quot; &quot;2by&quot;)
    =&gt; (list-of (+ x y) [x &lt;- '(1 2 3)] [y &lt;- 20 40 .. 100])
    (21 41 61 81 101 22 42 62 82 102 23 43 63 83 103)
    =&gt; (list-of (+ x y) [x &lt;- '(1 2 3) and y &lt;- 20 40 .. 100])
    (21 42 63)
    =&gt; (list-of y [x &lt;- 0 .. and y &lt;- '(a b c d e f g h i)] (even? x))
    (a c e g i)
    =&gt; (list-of y [x &lt;- 0 .. and y &lt;- '(a b c d e f g h i)]
         when (even? x) do (echo y))
    a
    c
    e
    g
    i
    (a c e g i)
    =&gt; (list-of (list x y) [x &lt;- 3 and y &lt;- 'x])
    ((0 x) (1 x) (2 x))
    =&gt; (list-of (list x y) [x &lt;- 3 and y &lt;- 'x ..])
    ((0 x) (1 x) (2 x))
    =&gt; (list-of (list x y) [x &lt;- #\0 .. and y &lt;- '(a b c d)])
    ((#\0 a) (#\1 b) (#\2 c) (#\3 d))
    =&gt; (list-of x [x &lt;- '(1 2 3) then (cdr x) until (null? x)])
    ((1 2 3) (2 3) (3))
    =&gt; (list-of (list x y)
         [x &lt;- '(1 2 3) then (cdr y) until (null? x) and
          y &lt;- '(10 20 30) then (cdr x) until (null? y)])
    (((1 2 3) (10 20 30)) ((20 30) (2 3)) ((3) (30)))
    =&gt; (list-of x [x &lt;- (lambda (yield) 42)])
    ()
    =&gt; (list-of x [x &lt;- (lambda (yield) (yield 42))])
    (42)
    =&gt; (list-of x [x &lt;- (lambda (yield) (yield (yield 42)))])
    (42 42)
    =&gt; (list-of x [x &lt;- (lambda (yield)
                          (for-each (lambda (x) (echo x) (yield x))
                                    '(3 2 1 0)))])
    3
    2
    1
    0
    (3 2 1 0)
    =&gt; (list-of x [x &lt;- (lambda (yield)
                          (for-each (lambda (x) (echo x) (yield (/ x)))
                                    '(3 2 1 0)))])
    3
    2
    1
    0
    /: division by zero
    =&gt; (list-of x
         [c &lt;- 3 and
          x &lt;- (lambda (yield)
                 (for-each (lambda (x) (echo x) (yield (/ x)))
                           '(3 2 1 0)))])
    3
    2
    1
    (1/3 1/2 1)
    =&gt; (define h (make-hash-table))
    =&gt; (set! (hash-table-get h 'x) 1
             (hash-table-get h 'y) 2
             (hash-table-get h 'z) 3)
    =&gt; (list-of x [x &lt;- h])
    ((y . 2) (z . 3) (x . 1))
    =&gt; (list-of x [x &lt;- 4 &lt;- 4 .. 0 &lt;- '(1 2 3)])
    (0 1 2 3 4 3 2 1 0 1 2 3)
    =&gt; (list-of (list x y)
         [x &lt;- 1 .. 3 &lt;- '(a b c) and
          y &lt;- (lambda (y) (y 'x) (y 'y)) &lt;- &quot;abcd&quot;])
    ((1 x) (2 y) (3 #\a) (a #\b) (b #\c) (c #\d))

  Note that parallel iteration is useful both for enumerating results,
  and for walking over a finite prefix of an infinite iteration.

  The following is an extensive list of various ranges:
    =&gt; (list-of x [x &lt;- 0 .. 6])
    (0 1 2 3 4 5 6)
    =&gt; (list-of x [x &lt;- 0 ..&lt; 6])
    (0 1 2 3 4 5)
    =&gt; (list-of x [x &lt;- 0 .. -6])
    (0 -1 -2 -3 -4 -5 -6)
    =&gt; (list-of x [x &lt;- 0 ..&lt; -6])
    (0 -1 -2 -3 -4 -5)
    =&gt; (list-of x [x &lt;- 0 2 .. 6])
    (0 2 4 6)
    =&gt; (list-of x [x &lt;- 0 2 ..&lt; 6])
    (0 2 4)
    =&gt; (list-of x [x &lt;- 0 -2 ..&lt; -6])
    (0 -2 -4)
    =&gt; (list-of x [x &lt;- #\a .. #\g])
    (#\a #\b #\c #\d #\e #\f #\g)
    =&gt; (list-of x [x &lt;- #\a ..&lt; #\g])
    (#\a #\b #\c #\d #\e #\f)
    =&gt; (list-of x [x &lt;- #\a #\c .. #\g])
    (#\a #\c #\e #\g)
    =&gt; (list-of x [x &lt;- #\a #\c ..&lt; #\g])
    (#\a #\c #\e)
    =&gt; (list-of x [x &lt;- #\g #\e ..&lt; #\a])
    (#\g #\e #\c)
    =&gt; (list-of x [x &lt;- 6 5 .. zero?])
    (6 5 4 3 2 1 0)
    =&gt; (list-of x [x &lt;- 6 5 ..&lt; zero?])
    (6 5 4 3 2 1)
    =&gt; (list-of x [x &lt;- 6 5 .. until zero?])
    (6 5 4 3 2 1)
    =&gt; (list-of x [x &lt;- 6 5 .. while positive?])
    (6 5 4 3 2 1)
    =&gt; (list-of x [x &lt;- '(1 2 3) cdr .. null?])
    ((1 2 3) (2 3) (3) ())
    =&gt; (list-of x [x &lt;- '(1 2 3) cdr ..&lt; null?])
    ((1 2 3) (2 3) (3))
    =&gt; (list-of x [x &lt;- '(1 2 3) cdr .. until null?])
    ((1 2 3) (2 3) (3))
    =&gt; (list-of x [x &lt;- '(1 2 3) cdr .. while pair?])
    ((1 2 3) (2 3) (3))
    =&gt; (list-of x [x &lt;- #\a #\d .. while char-alphabetic?])
    (#\a #\d #\g #\j #\m #\p #\s #\v #\y)
    =&gt; (list-of x [x &lt;- #\a #\d .. char-alphabetic?])
    (#\a)
    =&gt; (list-of x [x &lt;- #\a #\d ..&lt; char-alphabetic?])
    ()
    =&gt; (list-of x [x &lt;- 0 1 .. positive?])
    (0 1)
    =&gt; (list-of x [x &lt;- 1 2 .. positive?])
    (1)
    =&gt; (list-of x [x &lt;- 1 2 ..&lt; positive?])
    ()
    =&gt; (list-of x [x &lt;- '(a b c) ..&lt; pair?])
    ()
    =&gt; (list-of x [x &lt;- '(a b c) .. pair?])
    ((a b c))
    =&gt; (list-of x [x &lt;- '(a b c) cdr .. pair?])
    ((a b c))
    =&gt; (list-of x [x &lt;- read-line .. eof-object?])
    ...list of remaining input lines, including #&lt;eof&gt;...
    =&gt; (list-of x [x &lt;- read-line ..&lt; eof-object?])
    ...list of remaining input lines, excluding #&lt;eof&gt;...
    =&gt; (list-of x [x &lt;- read-line ..&lt; eof])
    ...the same...
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="152"><tt><b>collect-final</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[value]</td>
  </tr>
</table>
<pre>  This value can be used to terminate iterations: when it is returned as
  the iteration value (not the state), the iteration will terminate
  without using it.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="153"><tt><b>(function-iterator f [final-value])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  '<tt>f</tt>' is expected to be a function that can accept a single input value.
  It is applied on a '<tt>yield</tt>' function that can be used to return a value
  at any point.  The return value is a function of no argument, which
  returns on every application values that were passed to '<tt>yield</tt>'.  When
  '<tt>f</tt>' terminates, the final result of the iterated return value depends
  on the optional argument -- if none was supplied, the actual return
  value is returned, if a thunk was supplied it is applied for a return
  value, and if any other value was given it is returned.  After
  termination, calling the iterated function again results in an error.
  (The supplied '<tt>yield</tt>' function returns its supplied value to the
  calling context when resumed.)
    =&gt; (define (foo yield) (yield 1) (yield 2) (yield 3))
    =&gt; (define bar (function-iterator foo))
    =&gt; (list (bar) (bar) (bar))
    (1 2 3)
    =&gt; (bar)
    3
    =&gt; (bar)
    function-iterator: iterated function #&lt;procedure:foo&gt; exhausted.
    =&gt; (define bar (function-iterator foo 'done))
    =&gt; (list (bar) (bar) (bar) (bar))
    (1 2 3 done)
    =&gt; (bar)
    function-iterator: iterated function #&lt;procedure:foo&gt; exhausted.
    =&gt; (define bar (function-iterator foo (thunk (error 'foo &quot;done&quot;))))
    =&gt; (list (bar) (bar) (bar))
    (1 2 3)
    =&gt; (bar)
    foo: done
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="151"><tt><b>(collect-iterator sequence)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
  <tr>
    <td><a name="150"><tt><b>(collect-numerator from second to [flag])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  These functions are used to construct iterations.  '<a href="misc-doc.html#151" title="Documentation for 'swindle/collect-iterator.ss'"><tt>collect-iterator</tt></a>'
  is the function used to create iteration over a sequence object and it
  is used by `(x &lt;- sequence)' forms of '<a href="misc-doc.html#142" title="Documentation for 'swindle/collect.ss'"><tt>collect</tt></a>'.  '<a href="misc-doc.html#150" title="Documentation for 'swindle/collect-numerator.ss'"><tt>collect-numerator</tt></a>'
  create range iterations specified with `(x &lt;- from second to)' forms,
  where unspecified values are passed as '<tt>#f</tt>', and the flag argument is
  a '<tt>&lt;</tt>', '<a href="misc-doc.html#148" title="Documentation for 'swindle/while.ss'"><tt>while</tt></a>', or '<a href="misc-doc.html#149" title="Documentation for 'swindle/until.ss'"><tt>until</tt></a>' symbol for ranges specified with &quot;..&lt;&quot;,
  &quot;.. while&quot; and &quot;.. until&quot;.  These functions are available for
  implementing new iteration constructs, for example:
    =&gt; (define (in-values producer)
         (collect-iterator (call-with-values producer list)))
    =&gt; (list-of x [x &lt;- in-values (thunk (values 1 2 3))])
    (1 2 3)
  The return value that specifies an iteration is a list of four items:
  1. the initial state value;
  2. a '<tt>step</tt>' function that gets a state and returns the next one;
  3. a predicate for the end state (#f for none);
  4. a function that computes a value from the state variable.
  But usually the functions are more convenient.

  Finally, remember that you can return '<a href="misc-doc.html#152" title="Documentation for 'swindle/collect-final.ss'"><tt>collect-final</tt></a>' as the value to
  terminate any iteration.
</pre>
<hr>
<a name="154"><h2>Convenient printing</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="155"><tt><b>(echo arg ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  This is a handy printout utility that offers an alternative approach
  to '<tt>printf</tt>'-like output (it's a syntax, but it can be used as a
  regular function too, see below).  When applied, it simply prints its
  arguments one by one, using certain keywords to control its behavior:
  * :&gt;e     - output on the current-error-port;
  * :&gt;o     - output on the current-output-port (default);
  * :&gt;s     - accumulate output in a string which is the return value
              (string output sets '<tt>:n-</tt>' as default (unless
              pre-specified));
  * :&gt; p    - output on the given port '<tt>p</tt>', or a string if '<tt>#f</tt>';
  * :&gt;&gt; o   - use '<tt>o</tt>', a procedure that gets a value and a port, as the
              output handler (the procedure can take one value and
              display it on the current output port);
  * :d      - use '<tt>display</tt>' output (default);
  * :w      - use '<tt>write</tt>' output;
  * :d1 :w1 - change to a '<tt>display</tt>' or '<tt>write</tt>' output just for the next
              argument;
  * :s-     - no spaces between arguments;
  * :s+     - add spaces between arguments (default);
  * :n-     - do not print a final newline;
  * :n+     - terminate the output with a newline (default);
  * :n      - output a newline now;
  * : or :: - avoid a space at this point;
  * :\{     - begin a list construct (see below).
  Keywords that require additional argument are ignored if no argument
  is given.

  Recursive processing of a list begins with a '<tt>:\{</tt>' and ends with a
  '<tt>:\}</tt>' (which can be simpler if '<tt>read-curly-brace-as-paren</tt>' is off).
  Inside a list context, values are inspected and any lists cause
  iteration for all elements.  In each iteration, all non-list arguments
  are treated normally, but lists are dissected and a single element is
  printed in each step, terminating when the shortest list ends (and
  repeating a last '<tt>dotted</tt>' element of a list):
    =&gt; (define abc '(a b c))
    =&gt; (echo :\{ &quot;X&quot; abc :\})
    X a X b X c
    =&gt; (echo :\{ &quot;X&quot; abc '(1 2 3 4) :\})
    X a 1 X b 2 X c 3
    =&gt; (echo :\{ &quot;X&quot; abc '(1 . 2) :\})
    X a 1 X b 2 X c 2
  Inside a list context, the '<tt>:^</tt>' keyword can be used to stop this
  iteration if it is the last:
    =&gt; (echo :s- :\{ abc :^ &quot;, &quot; :\})
    a, b, c
  Nesting of lists is also simple, following these simple rules, by
  nesting the '<tt>:\{</tt>' ... '<tt>:\}</tt>' construct:
    =&gt; (echo :s- :\{ &quot;&lt;&quot; :\{ '((1 2) (3 4 5) 6 ()) :^ &quot;,&quot; :\} &quot;&gt;&quot;
                     :^ &quot;-&quot; :\})
    &lt;1,2&gt;-&lt;3,4,5&gt;-&lt;6&gt;-&lt;&gt;
  Note that this example is similar to the CL '<tt>format</tt>':
    (format t &quot;~{&lt;~{~a~^,~}&gt;~^-~}&quot; '((1 2) (3 4 5) 6 ()))
  except that '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' treats a dotted element (a non-list in this case)
  as repeating as needed.

  There are two additional special keywords that are needed only in
  uncommon situations:
  * :k-  - turn off keyword processing
  * :k+  - turn keyword processing on
  Usually, when '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' is used, it is processed by a macro that detects
  all keywords, even if there is a locally bound variable with a keyword
  name.  This means that keywords are only ones that are syntactically
  so, not expressions that evaluate to keywords.  The two cases where
  this matters are -- when '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' is used for its value (using it as a
  value, not in a head position) no processing is done so all keywords
  will just get printed; and when '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' is used in a context where a
  variable has a keyword name and you want to use its value (which not a
  great idea anyway, so there is no way around it).  The first case is
  probably more common, so the variable '<a href="misc-doc.html#156" title="Documentation for 'swindle/echo:.ss'"><tt>echo:</tt></a>' is bound to a special
  value that will force treating the next value as a keyword (if it
  evaluates to one) -- it can also be used to turn keyword processing on
  (which means that all keyword values will have an effect).  Here is a
  likely examples where '<a href="misc-doc.html#156" title="Documentation for 'swindle/echo:.ss'"><tt>echo:</tt></a>' should be used:
    =&gt; (define (echo-values vals)
         (apply echo &quot;The given values are:&quot; echo: :w vals))
    =&gt; (echo-values '(&quot;a&quot; &quot;b&quot; &quot;c&quot;))
    The given values are: &quot;a&quot; &quot;b&quot; &quot;c&quot;
    =&gt; (echo-values '(:a :b :c))
    The given values are: :a :b :c
  And here are some tricky examples:
    =&gt; (echo :&gt;s 2)
    &quot;2&quot;
    =&gt; (define e echo)                 ; '<tt>e</tt>' is the real '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' function
    =&gt; (e :&gt;s 2)                       ; no processing done here
    :&gt;s 2
    =&gt; (e echo: :&gt;s 2)                 ; explicit key
    &quot;2&quot;
    =&gt; (e echo: :k+ :&gt;s 2)             ; turn on keywords
    &quot;2&quot;
    =&gt; (let ([:&gt;s 1]) (echo :&gt;s 2))    ; '<tt>:&gt;s</tt>' was processed by '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>'
    &quot;2&quot;
    =&gt; (let ([:&gt;s 1]) (e :&gt;s 2))       ; '<tt>:&gt;s</tt>' was not processed
    1 2
    =&gt; (let ([:&gt;s 1]) (e echo: :&gt;s 2)) ; '<tt>:&gt;s</tt>' is not a keyword here!
    1 2
    =&gt; (let ([:&gt;s 1]) (echo echo: :&gt;s 2)) ; '<a href="misc-doc.html#156" title="Documentation for 'swindle/echo:.ss'"><tt>echo:</tt></a>' not needed
    &quot;2&quot;

  Finally, it is possible to introduce new keywords to '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>'.  This is
  done by calling it with the '<tt>:set-user</tt>' keyword, which expects a
  keyword to attach a handler to, and the handler itself.  The handler
  can be a simple value or a keyword that will be used instead:
    =&gt; (echo :set-user :foo &quot;foo&quot;)
    =&gt; (echo 1 :foo 2)
    1 foo 2
    =&gt; (echo :set-user :foo :n)
    =&gt; (echo 1 :foo 2)
    1
    2
  The '<tt>:set-user</tt>' keyword can appear with other arguments, it has a
  global effect in any case:
    =&gt; (echo 1 :foo :set-user :foo &quot;FOO&quot; 2 :foo 3
             :set-user :foo &quot;bar&quot; :foo 4)
    1
    2 FOO 3 bar 4
    =&gt; (echo 1 :foo 2)
    1 bar 2
  If the handler is a function, then when this keyword is used, the
  function is applied on arguments pulled from the remaining '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>'
  arguments that follow (if the function can get any number of
  arguments, then all remaining arguments are taken).  The function can
  work in two ways: (1) when it is called, the '<tt>current-output-port</tt>'
  will be the one that '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' currently prints to, so it can just print
  stuff; (2) if the function returns a list (or a single value which is
  not '<tt>#f</tt>' or '<tt>void</tt>'), then these values will be used instead of the
  taken arguments.  Some examples:
    =&gt; (echo :set-user :foo (thunk &quot;FOO&quot;) 1 :foo 2)
    1 FOO 2
    =&gt; (echo :set-user :add1 add1 1 :add1 2)
    1 3
    =&gt; (echo :set-user :+1 (lambda (n) (list n '+1= (add1 n))) :+1 2)
    2 +1= 3
    =&gt; (echo :set-user :&lt;&gt; (lambda args (append '(&quot;&lt;&quot;) args '(&quot;&gt;&quot;)))
             :&lt;&gt; 1 2 3)
    &lt; 1 2 3 &gt;
  Care should be taken when user keywords are supposed to handle other
  keywords -- the '<a href="misc-doc.html#156" title="Documentation for 'swindle/echo:.ss'"><tt>echo:</tt></a>' tag will usually be among the arguments except
  when '<tt>:k+</tt>' was used and an argument value was received.  This exposes
  the keyword treatment hack and might change in the future.

  To allow user handlers to change settings temporarily, there are
  '<tt>:push</tt>' and '<tt>:pop</tt>' keywords that will save and restore the current
  state (space and newline flags, output type and port etc).  For
  example:
    =&gt; (echo :set-user :@
             (lambda (l)
               (echo-quote
                list :push :s- :\{ &quot;\&quot;&quot; l &quot;\&quot;&quot; :^ &quot;, &quot; :\} :pop)))
    =&gt; (echo 1 :@ '(2 3 4) 5)
    1 &quot;2&quot;, &quot;3&quot;, &quot;4&quot; 5
  The above example shows another helper tool -- the '<a href="misc-doc.html#157" title="Documentation for 'swindle/echo-quote.ss'"><tt>echo-quote</tt></a>'
  syntax: `(echo-quote head arg ...)' will transform into `(head ...)',
  where keyword arguments are prefix with the '<a href="misc-doc.html#156" title="Documentation for 'swindle/echo:.ss'"><tt>echo:</tt></a>' tag.  Without it,
  things would look much worse.

  In addition to '<tt>:set-user</tt>' there is an '<tt>:unset-user</tt>' keyword which
  cancels a keyword handler.  Note that built-in keywords cannot be
  overridden or unset.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="158"><tt><b>(echos arg ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Just uses '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' with '<tt>:&gt;s</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="156"><tt><b>echo:</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[value]</td>
  </tr>
</table>
<pre>  See the '<a href="misc-doc.html#155" title="Documentation for 'swindle/echo.ss'"><tt>echo</tt></a>' description for usage of this value.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="159"><tt><b>(named-lambda name args body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Like '<a href="base-doc.html#8" title="Documentation for 'swindle/lambda.ss'"><tt>lambda</tt></a>', but the name is bound to itself in the body.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="131"><tt><b>(thunk body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Returns a procedure of no arguments that will have the given body.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="148"><tt><b>(while condition body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="149"><tt><b>(until condition body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Simple looping constructs.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="160"><tt><b>(dotimes (i n) body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Loop '<tt>n</tt>' times, evaluating the body when '<tt>i</tt>' is bound to 0,1,...,n-1.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="161"><tt><b>(dolist (x list) body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Loop with '<tt>x</tt>' bound to elements of '<tt>list</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="162"><tt><b>(no-errors body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Execute body, catching all errors and returning '<tt>#f</tt>' if one occurred.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="163"><tt><b>(no-errors* body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Execute body, catching all errors and returnsthe exception if one
  occured.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="164"><tt><b>(regexp-case string clause ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Try to match the given '<tt>string</tt>' against several regexps.  Each clause
  has one of the following forms:
  * (re =&gt; function): if '<tt>string</tt>' matches '<tt>re</tt>', apply '<tt>function</tt>' on the
    result list.
  * ((re args ...) body ...): if '<tt>string</tt>' matches '<tt>re</tt>', bind the tail of
    results (i.e, excluding the whole match result) to the given
    arguments and evaluate the body.  The whole match result (the first
    element of '<tt>regexp-match</tt>') is bound to '<a href="extra-doc.html#165" title="Documentation for 'swindle/match.ss'"><tt>match</tt></a>'.
  * (re body ...): if '<tt>string</tt>' matches '<tt>re</tt>', evaluate the body -- no
    match results are available.
  * (else body ...): should be the last clause which is evaluated if all
    previous cases failed.
</pre>
<hr>
<a name="166"><h2>Sorting</h2></a>
<pre>The following section defines functions for sorting.  They are taken
directly from slib since they are more convenient and faster than the
functions in mzlib/list.  See the source for more details.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="167"><tt><b>(sorted? sequence less?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  True when '<tt>sequence</tt>' is a list (x0 x1 ... xm) or a vector #(x0 ... xm)
  such that its elements are sorted according to '<tt>less?</tt>':
    (not (less? (list-ref list i) (list-ref list (- i 1)))).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="168"><tt><b>(merge a b less?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Takes two lists '<tt>a</tt>' and '<tt>b</tt>' such that both (sorted? a less?) and
  (sorted? b less?) are true, and returns a new list in which the
  elements of '<tt>a</tt>' and '<tt>b</tt>' have been stably interleaved so that (sorted?
  (merge a b less?) less?) is true.  Note: this does not accept vectors.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="169"><tt><b>(merge! a b less?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Takes two sorted lists '<tt>a</tt>' and '<tt>b</tt>' and smashes their cdr fields to
  form a single sorted list including the elements of both.  Note: this
  does not accept vectors.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="170"><tt><b>(sort! sequence less?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Sorts the list or vector '<tt>sequence</tt>' destructively.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="171"><tt><b>(sort sequence less?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[procedure]</td>
  </tr>
</table>
<pre>  Sorts a vector or list non-destructively.  It does this by sorting a
  copy of the sequence.
</pre>
</body>
</html>
<!-- Generated by Swindle/html -->
