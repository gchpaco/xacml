<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Generated by Swindle/html (http://www.barzilay.org/Swindle/) -->
<html>
<head>
  <title>Documentation for 'swindle/clos.ss'</title>
</head>
<body bgcolor="#C0C0FF" text="#000000" link="#B00000" vlink="#600000" alink="#FF0000">
<h1 align="center">Documentation for '<tt>swindle/clos.ss</tt>'</h1>
<hr>
<p>
This module contains only syntax definitions, which makes Swindle closer
to CLOS -- making the object system much more convenient to use.
</p>
<p>
This module exports bindings from: '<tt>mzlib/tiny-clos</tt>'.
</p>
<hr>
<hr>
<a name="331"><h2>Generic macros</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="332"><tt><b>(generic)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>| (generic name initargs ...)
| (generic name (arg ...) initargs ...)
  Create a generic function object (an instance of the
  '<a href="tiny-clos-doc.html#249" title="Documentation for 'swindle/*default-generic-class*.ss'"><tt>*default-generic-class*</tt></a>' parameter).  The first form uses the default
  name given by the syntactical context, the second one gets an explicit
  name and the third also gets a list of arguments which is used to
  count the required number of arguments.  If there is no argument list
  to count, the first method that gets added will set this number.  The
  two last forms allow initargs to be passed to the &lt;generic&gt; instance
  creation, for example, to specify a '<tt>:combination</tt>' argument.  (The
  first form does not allow keywords, since a keyword would be taken as
  the name.)
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="333"><tt><b>(defgeneric name (arg ...) initargs ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>| (defgeneric (name arg ...) initargs ...)
| (defgeneric name initargs ...)
  This form defines a generic function using the '<a href="clos-doc.html#332" title="Documentation for 'swindle/generic.ss'"><tt>generic</tt></a>' syntax given
  above.  The last form doesn't specify a number of arguments.  Some
  extra '<tt>initargs</tt>' can be specified too but they are needed mainly for a
  '<tt>:combination</tt>' argument.
</pre>
<hr>
<a name="334"><h2>Method macros</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="203"><tt><b>(call-next-method [args ...])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[local]</td>
  </tr>
  <tr>
    <td><a name="335"><tt><b>(next-method?)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[local]</td>
  </tr>
</table>
<pre>  These are bindings which are available only in method bodies.
  '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>' will invoke the next method in a generic invocation
  sequence if any.  If arguments are given to '<a href="clos-doc.html#203" title="Documentation for 'swindle/call-next-method.ss'"><tt>call-next-method</tt></a>', it
  will change the arguments for the next method -- but this is done when
  the methods are already filtered and sorted, so the new arguments
  should always be consistent with the old types.  If there are no
  methods left, or when calling a method directly, or when a before or
  after method is used, the '<a href="tiny-clos-doc.html#217" title="Documentation for 'swindle/no-next-method.ss'"><tt>no-next-method</tt></a>' generic will be used --
  normally resulting in an error.  '<a href="clos-doc.html#335" title="Documentation for 'swindle/next-method?.ss'"><tt>next-method?</tt></a>' returns '<tt>#t</tt>' if there
  is another method ready to be called.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="336"><tt><b>(method (arg ...) body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="337"><tt><b>(named-method name (arg ...) body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="338"><tt><b>(qualified-method qualifier (arg ...) body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These forms are all similar variants to create a method object (and
  instance of the '<a href="tiny-clos-doc.html#248" title="Documentation for 'swindle/*default-method-class*.ss'"><tt>*default-method-class*</tt></a>' parameter).  A method looks
  very similar to a lambda expression, except that the an argument can
  be a of the form `[arg spec]' where '<tt>spec</tt>' is a specializer -- either
  a class or a singleton specifier (the square brackets are equivalent
  to round parens, just make the code more readable).  Also, an argument
  can have the form of `[arg = val]' which is shorthand for specifying
  `[arg (singleton val)]'.  In case of a simple argument, &lt;top&gt; is
  always used as a specializer, but this processing stops as soon as a
  &amp;-keyword is encountered.  The '<a href="clos-doc.html#337" title="Documentation for 'swindle/named-method.ss'"><tt>named-method</tt></a>' form is used to provide
  an explicit name (which can be used to call itself recursively) , and
  '<a href="clos-doc.html#338" title="Documentation for 'swindle/qualified-method.ss'"><tt>qualified-method</tt></a>' is used to provide an explicit qualifier (which
  should be one of the standard qualifiers (:primary, :around, :before,
  or :after) when using the standard &lt;method&gt; and &lt;generic&gt; classes).

  The resulting method can be added to a generic and these specializers
  will be used when filtering applicable methods, or it can be used by
  itself and the specializers will be used to check the arguments.  This
  makes it easy to use '<a href="clos-doc.html#336" title="Documentation for 'swindle/method.ss'"><tt>method</tt></a>' instead of '<a href="base-doc.html#8" title="Documentation for 'swindle/lambda.ss'"><tt>lambda</tt></a>' to get some type
  information, but note that the result is going to run slower since the
  type check only takes time but cannot be used by MzScheme to optimize
  the code.

  Note that the specializer argument are evaluated normally, which means
  that anything can be used, even something like:
    (let ([x (list &lt;string&gt; &lt;integer&gt;)])
      (method ([x (2nd x)] [y = (+ 2 3)]) (+ x y)))
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="339"><tt><b>(-defmethod-create-generics- [#t/#f])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax-parameter]</td>
  </tr>
</table>
<pre>  This is a syntax parameter (see above) holding a boolean.  When this
  is set to '<tt>#t</tt>' (the default), then the '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>' form below will try
  to detect when the first definition happens and automatic add a
  '<a href="clos-doc.html#333" title="Documentation for 'swindle/defgeneric.ss'"><tt>defgeneric</tt></a>' form to define the object as a generic.  A safer but less
  convenient approach would be to set this to '<tt>#f</tt>' and always do an
  explicit '<a href="clos-doc.html#333" title="Documentation for 'swindle/defgeneric.ss'"><tt>defgeneric</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="340"><tt><b>(defmethod name [qualifier] (arg ...) body ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>| (defmethod [qualifier] (name arg ...) body ...)
  This form is used to define a method object using '<a href="clos-doc.html#336" title="Documentation for 'swindle/method.ss'"><tt>method</tt></a>' and its
  variants above.  A qualifier (a :keyword) can be specified anywhere
  before the argument list, and the name can be either specified before
  the arguments (Lisp style) or with the arguments (Scheme style).
  Depending on '<a href="clos-doc.html#339" title="Documentation for 'swindle/-defmethod-create-generics-.ss'"><tt>-defmethod-create-generics-</tt></a>' (see above), this form
  might add a '<a href="clos-doc.html#333" title="Documentation for 'swindle/defgeneric.ss'"><tt>defgeneric</tt></a>' form to define the given '<tt>name</tt>' as a generic
  object, and then add the created method.  The created method is
  attached to the generic in any case, which makes the name of this form
  a little misleading since it is not always defining a variable value.
  In a local definition context, this should do the right thing as long
  as '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>' or '<a href="clos-doc.html#333" title="Documentation for 'swindle/defgeneric.ss'"><tt>defgeneric</tt></a>' is used to define the method (but note
  that using a local generic function, is very inefficient) -- for
  example, both of these work (defining a local generic):
    (define (f)
      (defgeneric foo)
      (defmethod (foo [x &lt;c1&gt;]) 1)
      (defmethod (foo [x &lt;c2&gt;]) 2)
      3)
    (define (f)
      (defmethod (foo [x &lt;c1&gt;]) 1)
      (defmethod (foo [x &lt;c2&gt;]) 2)
      3)
  but this fails because the first '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>' doesn't know that it is
  already defined:
    (define (f)
      (define foo (generic foo))
      (defmethod (foo [x c1]) 1)
      (defmethod (foo [x c1]) 2)
      3)
  second &quot;but&quot; -- this:
    (define (f)
      (define foo (generic foo))
      blah
      (defmethod (foo [x &lt;c1&gt;]) 1)
      (defmethod (foo [x &lt;c2&gt;]) 2)
      3)
  works because a '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>' in an expression context is always the
  same as '<a href="tiny-clos-doc.html#231" title="Documentation for 'swindle/add-method.ss'"><tt>add-method</tt></a>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="341"><tt><b>(beforemethod ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="342"><tt><b>(aftermethod ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="343"><tt><b>(aroundmethod ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="344"><tt><b>(defbeforemethod ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="345"><tt><b>(defaftermethod ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="346"><tt><b>(defaroundmethod ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These forms are shorthands that will generate a qualified method using
  one of the standard qualifiers.
</pre>
<hr>
<a name="347"><h2>Class macros</h2></a>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="241"><tt><b>(class [name] (super ...) slot ... class-initarg ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Create a class object (an instance of the '<a href="tiny-clos-doc.html#250" title="Documentation for 'swindle/*default-class-class*.ss'"><tt>*default-class-class*</tt></a>'
  parameter).  An explicit name can optionally be specified explicitly.
  The list of superclasses are evaluated normally, so they can be any
  expression (as with the '<a href="clos-doc.html#336" title="Documentation for 'swindle/method.ss'"><tt>method</tt></a>' forms).  Each slot can be either a
  symbol, which will be used as the slot name, or a list that begins
  with a symbol and continues with a keyword-argument option list.
  Finally, more initargs for the class generation can be provided.  See
  the '<a href="clos-doc.html#256" title="Documentation for 'swindle/defclass.ss'"><tt>defclass</tt></a>' forms below for an explanation on the available slot
  option and class initargs.  If a name is given, then '<a href="tiny-clos-doc.html#255" title="Documentation for 'swindle/rec-make.ss'"><tt>rec-make</tt></a>' is
  used, see that for a description.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="348"><tt><b>(entityclass [name] (super) slot ... class-initarg ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  Same as the '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>' form, but creates an entity class object (an
  instance of the '<a href="tiny-clos-doc.html#251" title="Documentation for 'swindle/*default-entityclass-class*.ss'"><tt>*default-entityclass-class*</tt></a>' parameter).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="349"><tt><b>(-defclass-auto-initargs- [#f/initargs])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax-parameter]</td>
  </tr>
</table>
<pre>  This is a syntax parameter (see above) holding either '<tt>#f</tt>' or an
  initargs list .  If it is not '<tt>#f</tt>', '<a href="clos-doc.html#256" title="Documentation for 'swindle/defclass.ss'"><tt>defclass</tt></a>' below will add its
  contents to the end of the given initargs (so user supplied arguments
  can override them).  The default is '<tt>#f</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="350"><tt><b>(-defclass-autoaccessors-naming- [naming-keyword])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax-parameter]</td>
  </tr>
</table>
<pre>  This syntax parameter holds a keyword symbol that is used in the
  '<a href="clos-doc.html#256" title="Documentation for 'swindle/defclass.ss'"><tt>defclass</tt></a>' for the '<tt>:autoaccessors</tt>' if it is specified as '<tt>#t</tt>' or if
  it used due to '<tt>:auto</tt>'.  See the description of the '<tt>:autoaccessors</tt>'
  option below for possible values.  The default is '<tt>:class-slot</tt>'.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="351"><tt><b>(-defclass-accessor-mode- [mode-keyword])</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax-parameter]</td>
  </tr>
</table>
<pre>  This syntax parameter holds a keyword symbol that is used in the
  '<a href="clos-doc.html#256" title="Documentation for 'swindle/defclass.ss'"><tt>defclass</tt></a>' for the way accessors, readers, and writers are generated.
  It can be '<tt>:defmethod</tt>' for using '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>', '<tt>:defgeneric</tt>' for using
  '<a href="clos-doc.html#333" title="Documentation for 'swindle/defgeneric.ss'"><tt>defgeneric</tt></a>' and then '<a href="tiny-clos-doc.html#231" title="Documentation for 'swindle/add-method.ss'"><tt>add-method</tt></a>', '<tt>:add-method</tt>' for using
  '<a href="tiny-clos-doc.html#231" title="Documentation for 'swindle/add-method.ss'"><tt>add-method</tt></a>', '<tt>:method</tt>' for defining an independent method, or
  '<tt>:procedure</tt>' for defining a simple Scheme procedure.  The default is
  `:defmethod.  This default is usually fine, but a situation where this
  is important is if the syntax parameter '<a href="clos-doc.html#339" title="Documentation for 'swindle/-defmethod-create-generics-.ss'"><tt>-defmethod-create-generics-</tt></a>'
  is set to '<tt>#f</tt>' so a '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>' requires a prior '<a href="clos-doc.html#333" title="Documentation for 'swindle/defgeneric.ss'"><tt>defgeneric</tt></a>' so a
  defclass will not work unless the generic functions are defined in
  advance.
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="256"><tt><b>(defclass name (super ...) slot ... class-initarg ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  This form uses the '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>' form above to define a new class.  See the
  '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>' form for the syntax.  Note that slot-options that are not
  compile-time ones (method names) are accumulated according to the
  class precedence list.

  Available slot options are:
  * :initarg keyword
    Use '<tt>keyword</tt>' in '<a href="tiny-clos-doc.html#213" title="Documentation for 'swindle/make.ss'"><tt>make</tt></a>' to provide a value for this slot.
  * :initializer func
    Use the given function to initialize the slot -- either a thunk or a
    function that will be applied on the initargs given to '<a href="tiny-clos-doc.html#213" title="Documentation for 'swindle/make.ss'"><tt>make</tt></a>'.
  * :initvalue value
    Use '<tt>value</tt>' as the default for this slot.
  * :reader name
    Define '<tt>name</tt>' (an unquoted symbol) as a reader method for this slot.
  * :writer name
    Define '<tt>name</tt>' (an unquoted symbol) as a writer method for this slot.
  * :accessor name
    Define '<tt>name</tt>' (an unquoted symbol) as an accessor method for this
    slot -- this means that two methods are defined: '<tt>name</tt>' and
    '<tt>set-name!</tt>'.
  * :type type
    Restrict this slot value to objects of the given '<tt>type</tt>'.
  * :lock { #t | #f | value }
    If specified and non-'<tt>#f</tt>', then this slot is locked.  '<tt>#t</tt>' locks it
    permanently, but a diffrent value works as a key: they allow setting
    the slot by using cons of the key and the value to set.
  * :allocation { :class | :instance }
    Specify that this slot is a normal one ('<tt>:instance</tt>', the default),
    or allocated per class ('<tt>:class</tt>').
  The specific way of creating helper methods (for readers, writers, and
  accessors) is determined by '<a href="clos-doc.html#351" title="Documentation for 'swindle/-defclass-accessor-mode-.ss'"><tt>-defclass-accessor-mode-</tt></a>' (see above).

  Available class options (in addition to normal ones that initialize
  the class slots like '<tt>:name</tt>', '<tt>:direct-slots</tt>', '<tt>:direct-supers</tt>') are:
  * :metaclass class
    create a class object which is an instance of the '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>'
    meta-class (this means that an instance of the given meta-class
    should be used for creating the new class).
  * :autoinitargs { #t | #f }
    if set to '<tt>#t</tt>', make the class definition automatically generate
    initarg keywords from the slot names.
  * :autoaccessors { #f | #t | :class-slot | :slot }
    if set to non-'<tt>#f</tt>', generate accessor methods automatically --
    either using the classname &quot;-&quot; slotname convention ('<tt>:class-slot</tt>')
    or just the slotname ('<tt>:slot</tt>').  If it is '<tt>#t</tt>' (or turned on by
    '<tt>:auto</tt>') then the default naming style is taken from the
    '<a href="clos-doc.html#350" title="Documentation for 'swindle/-defclass-autoaccessors-naming-.ss'"><tt>-defclass-autoaccessors-naming-</tt></a>' syntax parameter.  Note that for
    this, and other external object definitions ('<tt>:automaker</tt>' and
    '<tt>:autopred</tt>'), the class name is stripped of a surrounding &quot;&lt;&gt;&quot;s if
    any.
  * :automaker { #f | #t }
    automatically creates a '<tt>maker</tt>' function using the &quot;make-&quot; classname
    naming convention.  The maker function is applied on arguments and
    keyword-values -- if there are n slots, then arguments after the
    first n are passed to '<a href="tiny-clos-doc.html#213" title="Documentation for 'swindle/make.ss'"><tt>make</tt></a>' to create the instance, then the first
    n are '<a href="tiny-clos-doc.html#179" title="Documentation for 'swindle/slot-set!.ss'"><tt>slot-set!</tt></a>'ed into the n slots.  This means that it can get
    any number of arguments, and usually there is no point in additional
    keyword values (since if they initialize slots, their values will
    get overridden anyway).  It also means that the order of the
    arguments depend on the *complete* list of the class's slots (as
    given by '<a href="tiny-clos-doc.html#190" title="Documentation for 'swindle/class-slots.ss'"><tt>class-slots</tt></a>'), so use caution when doing multiple
    inheritance (actually, in that case it is probably better to avoid
    these makers anyway).
  * :autopred { #f | #t }
    automatically create a predicate function using the `classname &quot;?&quot;'
    naming convention.
  * :default-slot-options { #f | '(keyword ...) }
    if specified as a quoted list, then slot descriptions are modified
    so the first arguments are taken as values to the specified
    keywords.  For example, if it is `'(:type :initvalue)' then a slot
    description can have a single argument for '<tt>:type</tt>' after the slot
    name, a second argument for '<tt>:initvalue</tt>', and the rest can be more
    standard keyword-values.  This is best set with
    '<a href="clos-doc.html#349" title="Documentation for 'swindle/-defclass-auto-initargs-.ss'"><tt>-defclass-auto-initargs-</tt></a>'
  * :auto { #f | #t }
    if specified as '<tt>#t</tt>', then all automatic behavior available above is
    turned on.
  * :printer { #f | #t | procedure }
    if given, install a printer function.  '<tt>#t</tt>' means install the
    '<a href="extra-doc.html#352" title="Documentation for 'swindle/print-object-with-slots.ss'"><tt>print-object-with-slots</tt></a>' function from &quot;clos.ss&quot;, otherwise, it is
    expected to be a function that gets an object, an escape boolean
    flag an an optional port (i.e, 2 or more arguments), and prints the
    object on the class using the escape flag to select '<tt>display</tt>'-style
    ('<tt>#f</tt>') or '<tt>write</tt>'-style (#t).

  Note that the class object is made by '<a href="clos-doc.html#241" title="Documentation for 'swindle/class.ss'"><tt>class</tt></a>' with a name, so it is
  possible to use the class itself as the value of '<tt>:type</tt>' properties
  for a recursive class.

  Whenever the classname is used, it is taken from the defined name,
  without a surrounding &quot;&lt;&gt;&quot;s if any.  Note that some of these options
  are processed at compile time (all method names and auto-generation of
  methods).
</pre>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="353"><tt><b>(defentityclass name (super ...) slot ... class-initarg ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  The same as '<a href="clos-doc.html#256" title="Documentation for 'swindle/defclass.ss'"><tt>defclass</tt></a>', but for entity classes.
</pre>
<h3>Auto provide forms</h3>
<table width="100%" cellpadding="3" cellspacing="0" border="1" vspace="3" frame="border" rules="rows" bgcolor="#D0A0D0" bordercolor="#806080">
  <tr>
    <td><a name="354"><tt><b>(defgeneric* ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="355"><tt><b>(defclass* ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
  <tr>
    <td><a name="356"><tt><b>(defentityclass* ...)</b></tt></a></td>
    <td align="right">&nbsp;&nbsp;&nbsp;[syntax]</td>
  </tr>
</table>
<pre>  These forms are defined as the original version, except that the
  defined variable is automatically provided (made using
  '<a href="misc-doc.html#33" title="Documentation for 'swindle/make-provide-syntax.ss'"><tt>make-provide-syntax</tt></a>' above).  Note that there is no version for
  '<a href="clos-doc.html#340" title="Documentation for 'swindle/defmethod.ss'"><tt>defmethod</tt></a>' since it should not be used where a single definition
  place is needed -- and it wouldn't make sense to have multiple
  '<tt>provide</tt>' forms for every '<tt>defmethod*</tt>' occurrence.  Note that
  '<a href="clos-doc.html#355" title="Documentation for 'swindle/defclass*.ss'"><tt>defclass*</tt></a>' provides only the class identifier and not any
  automatically generated ones (accessors etc).
</pre>
</body>
</html>
<!-- Generated by Swindle/html -->
