<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from mzscheme.tex by tex2page, v 2004-09-11
(running on MzScheme 209, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
PLT MzScheme: Language Manual
</title>
<link rel="stylesheet" type="text/css" href="mzscheme-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
</head>
<body>
<div align=right class=navigation><i>[Go to <span><a href="mzscheme.html">first</a>, <a href="mzscheme-Z-H-7.html">previous</a></span><span>, <a href="mzscheme-Z-H-9.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="mzscheme.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="mzscheme-Z-H-19.html#node_index_start">index</a></span>]</i></div><p></p>
<a name="node_chap_8"></a>
<h1 class=chapter>
<div class=chapterheading><a href="mzscheme.html#node_toc_node_chap_8">Chapter 8</a></div><br>
<a href="mzscheme.html#node_toc_node_chap_8">Namespaces</a></h1>
<p><a name="node_idx_1294"></a></p>
<p>
<a name="node_idx_1296"></a>
MzScheme supports multiple <strong>namespaces</strong><a name="node_idx_1298"></a> for top-level
variable bindings, syntax bindings, module imports, and module
declarations.</p>
<p>
A new namespace is created with the <code class=scheme><code class=scheme>make-namespace</code></code> procedure,
which returns a first-class namespace value. A namespace is used by
setting the <code class=scheme><code class=scheme>current-namespace</code></code> parameter value (see
section&nbsp;<a href="mzscheme-Z-H-7.html#node_sec_7.7.1.5">7.7.1.5</a>), by providing the namespace to
procedures such as <code class=scheme><code class=scheme>eval</code></code> and <code class=scheme><span class=variable>eval-syntax</span></code>. The
MzScheme versions of the R5RS procedures
<a name="node_idx_1300"></a><code class=scheme>scheme-report-environment</code> and <a name="node_idx_1302"></a><code class=scheme>null-environment</code>
produce namespaces.<a name="call_footnote_Temp_16"></a><a href="#footnote_Temp_16"><sup><small>13</small></sup></a></p>
<p>
The current namespace is used by many procedures, including
<code class=scheme><code class=scheme>eval</code></code>, <code class=scheme><code class=scheme>load</code></code>, <code class=scheme><code class=scheme>compile</code></code>, and
<code class=scheme><code class=scheme>expand</code></code>.<a name="call_footnote_Temp_17"></a><a href="#footnote_Temp_17"><sup><small>14</small></sup></a> After an expression is
<code class=scheme><code class=scheme>eval</code></code>ed, the global variable references in the expression are
permanently attached to a particular namespace, so the current
namespace at the time that the code is executed is <em>not</em> used as
the namespace for referencing global variables in the expression.</p>
<p>
Example:
</p>
<div align=left><pre class=scheme>(<span class=keyword>define</span> <span class=variable>x</span> <span class=keyword>'</span><span class=variable>orig</span>) <span class=comment>; define in the original namespace </span>
<span class=comment>;; The following <code class=scheme><span class=keyword>let</span></code> expression is compiled in the original </span>
<span class=comment>;; namespace, so direct references to <code class=scheme><span class=variable>x</span></code> see <code class=scheme><span class=selfeval>'orig</span></code>. </span>
(<span class=keyword>let</span> ([<span class=variable>n</span> (<code class=scheme>make-namespace</code>)]) <span class=comment>; make new namespace </span>
  (<span class=keyword>parameterize</span> ([<code class=scheme>current-namespace</code> <span class=variable>n</span>]) 
    (<code class=scheme>eval</code> <span class=keyword>'</span>(<span class=keyword>define</span> <span class=variable>x</span> <span class=keyword>'</span><span class=keyword>new</span>)) <span class=comment>; evals in the new namespace </span>
    (<code class=scheme>display</code> <span class=variable>x</span>) <span class=comment>; displays 'orig </span>
    (<code class=scheme>display</code> (<code class=scheme>eval</code> <span class=keyword>'</span><span class=variable>x</span>)))) <span class=comment>; displays 'new </span>
</pre></div><p></p>
<p>
A namespace actually encapsulates two top-level environments: one for
normal expressions, and one for macro transformer expressions; see
section&nbsp;<a href="mzscheme-Z-H-12.html#node_chap_12">12</a> for more information about the transformer
environment. Module declarations are shared by the environments, but
module instances, variable bindings, syntax bindings, and module
imports are distinct. More precisely, the transformer environment
never contains any variable or syntax bindings, and its module
instances and imports are distinct from the instances and imports of
the normal top-level environment.</p>
<p>
Each namespace has a <strong>module registry</strong><a name="node_idx_1304"></a> that maps module names
to module declarations (see Chapter&nbsp;<a href="mzscheme-Z-H-5.html#node_chap_5">5</a>). The
<code class=scheme>module-&gt;namespace</code> procedure returns a namespace with the
same module registry as the current namespace, but whose environment
and bindings correspond to the body of an instantiated module. (This
facility is primarily useful for debugging.)</p>
<p>
</p>
<a name="node_sec_8.1"></a>
<h2><a href="mzscheme.html#node_toc_node_sec_8.1">8.1&nbsp;&nbsp;Identifier Resolution in Namespaces</a></h2>
<p><a name="node_idx_1306"></a></p>
<p>
Identifier resolution in a namespace's top-level environment, for
compilation or expansion, proceeds in two steps. First, the
environment determines whether the identifier is mapped to a
top-level variable, to syntax, or to a module import (which can be
either syntax or a variable). Second, if the identifier is mapped to
a top-level variable, then the variable's location is found; if the
identifier is mapped to syntax, then the expansion-time binding is
found; and if the identifier is mapped to an import, then the source
module is consulted.</p>
<p>
Importing a variable from a module with <code class=scheme><span class=keyword>require</span></code> is <em>not</em>
the same as defining the variable; the import does not create a new
top-level variable in the environment, but instead maps an identifier
to the module's variable, in the same way that a syntax definition
maps an identifier to a transformer.</p>
<p>
Redefining a previously-defined variable is the same as mutating the
variable with <code class=scheme><span class=keyword>set!</span></code>. Rebinding a syntax-bound or import-bound
identifier (to syntax or an import) replaces the old binding with the
new one for future uses of the environment.</p>
<p>
If an identifier is bound to syntax or to an import, then defining the
identifier as a variable shadows the syntax or import in future uses
of the environment. Similarly, if an identifier is bound to a
top-level variable, then binding the identifier to syntax or an
import shadows the variable; the variable's value remains unchanged,
however, and may be accessible through previously evaluated
expressions.</p>
<p>
Example:
</p>
<div align=left><pre class=scheme>(<span class=keyword>define</span> <span class=variable>x</span> <span class=selfeval>5</span>)
(<span class=keyword>define</span> (<span class=variable>f</span>) <span class=variable>x</span>)
<span class=variable>x</span> <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>5</span></code></span>
(<span class=variable>f</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>5</span></code></span>
(<span class=keyword>define-syntax</span> <code class=scheme><span class=keyword>x</span></code> (<span class=keyword>syntax-rules</span> ()))
<code class=scheme><span class=keyword>x</span></code> <span class=comment>; =&gt;  bad syntax</span>
(<span class=variable>f</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>5</span></code></span>
(<span class=keyword>define</span> <span class=variable>x</span> <span class=selfeval>7</span>)
<span class=variable>x</span> <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>7</span></code></span>
(<span class=variable>f</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>7</span></code></span>
(<span class=keyword>module</span> <span class=variable>m</span> <code class=scheme>mzscheme</code> (<span class=keyword>define</span> <span class=variable>x</span> <span class=selfeval>8</span>) (<span class=keyword>provide</span> <span class=variable>x</span>))
(<span class=keyword>require</span> <span class=variable>m</span>)
<span class=variable>x</span> <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>8</span></code></span>
(<span class=variable>f</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>7</span></code></span>
</pre></div><p></p>
<p>
</p>
<a name="node_sec_8.2"></a>
<h2><a href="mzscheme.html#node_toc_node_sec_8.2">8.2&nbsp;&nbsp;Initial Namespace</a></h2>
<p><a name="node_idx_1308"></a></p>
<p>
<a name="node_idx_1310"></a>
<a name="node_idx_1312"></a>
In the stand-alone MzScheme application, the initial namespace's
module registry contains declarations for <code class=scheme><code class=scheme>mzscheme</code></code> and the
primitive <code class=scheme><span class=selfeval>#%</span></code>-named modules (see section&nbsp;<a href="mzscheme-Z-H-5.html#node_sec_5.7">5.7</a>).  The
normal top-level environment of the initial namespace contains
imports for all MzScheme syntax, and it contains variable bindings
(as opposed to imports) for every built-in procedure and constant.
The transformer top-level environment of the initial namespace
imports all MzScheme syntax, procedures, and constants.</p>
<p>
Applications embedding MzScheme may extend or modify the set of
initial bindings, but they will usually only add primitive modules
with <code class=scheme><span class=selfeval>#%</span></code>-prefixed names. (MrEd adds <code class=scheme>#%mred-kernel</code>
for its graphical toolbox.)</p>
<p>
</p>
<a name="node_sec_8.3"></a>
<h2><a href="mzscheme.html#node_toc_node_sec_8.3">8.3&nbsp;&nbsp;Namespace Utilities</a></h2>
<p><a name="node_idx_1314"></a></p>
<p>
<a name="node_idx_1316"></a><a name="node_kw_definitionmake-namespace"></a><code class=scheme>(make-namespace</code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>flag-symbol</span></code>]<code class=scheme>)</code> creates a new namespace with a
new module registry; the <code class=scheme><span class=variable>flag-symbol</span></code> is an option that
determines the initial bindings in the namespace. The allowed values
for <code class=scheme><span class=variable>flag-symbol</span></code> are:
</p>
<ul><p>
</p>
<li><p><code class=scheme><span class=selfeval>'initial</span></code><a name="node_idx_1318"></a> (the default)  --  the new namespace
contains the module declarations of the initial namespace (see
section&nbsp;<a href="#node_sec_8.2">8.2</a>), and the new namespace's normal top-level
environment contains bindings and imports as in the initial
namespace. However, the namespace's transformer top-level
environment is empty.</p>
<p>
</p>
<li><p><code class=scheme><span class=selfeval>'empty</span></code><a name="node_idx_1320"></a>  --  creates a namespace with no initial
bindings or module declarations.</p>
<p>
</p>
</ul><p></p>
<p>
<a name="node_idx_1322"></a><a name="node_kw_definitionnamespace_Q_"></a><code class=scheme>(namespace?</code><tt>&nbsp;</tt><code class=scheme><span class=variable>v</span></code><code class=scheme>)</code> returns <code class=scheme><span class=selfeval>#t</span></code> if <code class=scheme><span class=variable>v</span></code> is a namespace value,
<code class=scheme><span class=selfeval>#f</span></code> otherwise.</p>
<p>
<a name="node_idx_1324"></a><a name="node_kw_definitionnamespace-symbol->identifier"></a><code class=scheme>(namespace-symbol-&gt;identifier</code><tt>&nbsp;</tt><code class=scheme><span class=variable>symbol</span></code><code class=scheme>)</code> is similar to
<code class=scheme>datum-&gt;syntax-object</code> (see section&nbsp;<a href="mzscheme-Z-H-12.html#node_sec_12.2.2">12.2.2</a>) restricted to
symbols. The lexical context of the resulting identifier corresponds
to the top-level environment of the current namespace; the identifier
has no source location or properties.</p>
<p>
<a name="node_idx_1326"></a><a name="node_kw_definitionnamespace-variable-value"></a><code class=scheme>(namespace-variable-value</code><tt>&nbsp;</tt><code class=scheme><span class=variable>symbol</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>use-mapping? failure-thunk</span></code>]<code class=scheme>)</code>
returns a value for <code class=scheme><span class=variable>symbol</span></code> in the current namespace. The
returned value depends on <code class=scheme><span class=variable>use-mapping?</span></code>:
</p>
<ul><p>
</p>
<li><p>If <code class=scheme><span class=variable>use-mapping?</span></code> is true (the default), and if
<code class=scheme><span class=variable>symbol</span></code> maps to a top-level variable or an imported variable
(see section&nbsp;<a href="#node_sec_8.1">8.1</a>), then the result is the same as
evaluating <code class=scheme><span class=variable>symbol</span></code> as an expression. If <code class=scheme><span class=variable>symbol</span></code> maps to
syntax or imported syntax, the <a name="node_idx_1328"></a><code class=scheme>exn:syntax</code> exception is raised (or
<code class=scheme><span class=variable>failure-thunk</span></code> is called; see below). If <code class=scheme><span class=variable>symbol</span></code> is
mapped to an undefined variable or an uninitialized module
variable, the <a name="node_idx_1330"></a><code class=scheme>exn:variable</code> exception is raised (or <code class=scheme><span class=variable>failure-thunk</span></code> is
called).</p>
<p>
</p>
<li><p>If <code class=scheme><span class=variable>use-mapping?</span></code> is false, the namespace's syntax and
import mappings are ignored. Instead, the value of the top-level
variable named <code class=scheme><span class=variable>symbol</span></code> in namespace is returned. If the
variable is undefined, the <a name="node_idx_1332"></a><code class=scheme>exn:variable</code> exception is raised (or
<code class=scheme><span class=variable>failure-thunk</span></code> is called).</p>
<p>
</p>
</ul><p>
If <code class=scheme><span class=variable>failure-thunk</span></code> is provided, <code class=scheme>namespace-variable-value</code>
calls <code class=scheme><span class=variable>failure-thunk</span></code> to produce the return value in place of
raising an <a name="node_idx_1334"></a><code class=scheme>exn:variable</code> or <a name="node_idx_1336"></a><code class=scheme>exn:syntax</code> exception.</p>
<p>
<a name="node_idx_1338"></a><a name="node_kw_definitionnamespace-set-variable-value!"></a><code class=scheme>(namespace-set-variable-value!</code><tt>&nbsp;</tt><code class=scheme><span class=variable>symbol v</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>map?</span></code>]<code class=scheme>)</code> sets the value of
<code class=scheme><span class=variable>symbol</span></code> in the top-level environment of the current namespace,
defining <code class=scheme><span class=variable>symbol</span></code> if it is not already defined. If <code class=scheme><span class=variable>map?</span></code>
is supplied as true, then the namespace's identifier mapping is also
adjusted (see section&nbsp;<a href="#node_sec_8.1">8.1</a>) so that <code class=scheme><span class=variable>symbol</span></code> maps to the
variable. The default value for <code class=scheme><span class=variable>map?</span></code> is <code class=scheme><span class=selfeval>#f</span></code>.</p>
<p>
<a name="node_idx_1340"></a><a name="node_kw_definitionnamespace-undefine-variable!"></a><code class=scheme>(namespace-undefine-variable!</code><tt>&nbsp;</tt><code class=scheme><span class=variable>symbol</span></code><code class=scheme>)</code> removes the <code class=scheme><span class=variable>symbol</span></code>
variable, if any, in the top-level environment of the current
namespace. The namespace's identifier mapping is unaffected.</p>
<p>
<a name="node_idx_1342"></a><a name="node_kw_definitionnamespace-mapped-symbols"></a><code class=scheme>(namespace-mapped-symbols</code><code class=scheme>)</code> returns a list of all symbols that are
mapped to variables, syntax, and imports in the current namespace.</p>
<p>
<a name="node_idx_1344"></a><a name="node_kw_definitionnamespace-require"></a><code class=scheme>(namespace-require</code><tt>&nbsp;</tt><code class=scheme><span class=variable>quoted-require-spec</span></code><code class=scheme>)</code> performs the import
corresponding to <code class=scheme><span class=variable>quoted-require-spec</span></code> in the top-level
environment of the current namespace (like a top-level
<code class=scheme><span class=keyword>require</span></code> expression). See also Chapter&nbsp;<a href="mzscheme-Z-H-5.html#node_chap_5">5</a>.  Module
paths in <code class=scheme><span class=variable>quoted-require-spec</span></code> are not resolved with respect to
any other module, even if the current namespace corresponds to a
module body.</p>
<p>
<a name="node_idx_1346"></a><a name="node_kw_definitionnamespace-transformer-require"></a><code class=scheme>(namespace-transformer-require</code><tt>&nbsp;</tt><code class=scheme><span class=variable>quoted-require-spec</span></code><code class=scheme>)</code> performs the
import corresponding to <code class=scheme><span class=variable>quoted-require-spec</span></code> in the top-level
transformer environment (like a top-level <code class=scheme><span class=keyword>require-for-syntax</span></code>
expression). See also Chapter&nbsp;<a href="mzscheme-Z-H-5.html#node_chap_5">5</a>. Module paths in
<code class=scheme><span class=variable>quoted-require-spec</span></code> are not resolved with respect to any other
module, even if the current namespace corresponds to a module body.</p>
<p>
<a name="node_idx_1348"></a><a name="node_kw_definitionnamespace-require/copy"></a><code class=scheme>(namespace-require/copy</code><tt>&nbsp;</tt><code class=scheme><span class=variable>quoted-require-spec</span></code><code class=scheme>)</code> is like
<code class=scheme>namespace-require</code> for syntax exported from the module, but
exported variables are treated differently: the export's current
value is copied to a top-level variable in the current namespace.</p>
<p>
<a name="node_idx_1350"></a><a name="node_kw_definitionnamespace-require/expansion-time"></a><code class=scheme>(namespace-require/expansion-time</code><tt>&nbsp;</tt><code class=scheme><span class=variable>quoted-require-spec</span></code><code class=scheme>)</code> is like
<code class=scheme>namespace-require</code>, but only the transformer part of the
module is executed. If the required module has not been invoked
before, the module's variables remain undefined.</p>
<p>
<a name="node_idx_1352"></a><a name="node_kw_definitionnamespace-attach-module"></a><code class=scheme>(namespace-attach-module</code><tt>&nbsp;</tt><code class=scheme><span class=variable>src-namespace module-symbol</span></code><code class=scheme>)</code> attaches
the instantiated module named <code class=scheme><span class=variable>module-symbol</span></code> in
<code class=scheme><span class=variable>src-namespace</span></code> to the current namespace's registry, using
<code class=scheme><span class=variable>module-symbol</span></code> as the module name in the current namespace. In
addition to the <code class=scheme><span class=variable>module-symbol</span></code> module itself, every module that
it imports (directly or indirectly) is also recorded in the current
namespace's registry. If <code class=scheme><span class=variable>module-symbol</span></code> is not the name of an
instantiated module in <code class=scheme><span class=variable>src-namespace</span></code>, or if the name of any
module to be attached already has a different declaration or instance
in the current namespace, then the
<a name="node_idx_1354"></a><code class=scheme>exn:application:mismatch</code> exception is raised.</p>
<p>
<a name="node_idx_1356"></a><a name="node_kw_definitionnamespace-module-registry"></a><code class=scheme>(namespace-module-registry</code><tt>&nbsp;</tt><code class=scheme><span class=variable>namespace</span></code><code class=scheme>)</code> returns the registry of the
given namespace. This value is useful only for identification via
<code class=scheme><code class=scheme>eq?</code></code>.</p>
<p>
<a name="node_idx_1358"></a><a name="node_kw_definitionmodule->namespace"></a><code class=scheme>(module-&gt;namespace</code><tt>&nbsp;</tt><code class=scheme><span class=variable>module-path-v</span></code><code class=scheme>)</code> returns a namespace that
corresponds to the body of an instantiated module in the current
namespace's registry. The returned namespace has the same module
registry as the current namespace. Modifying a binding in the
namespace changes the binding seen in modules that require the
namespace's module. Module paths in a top-level <code class=scheme><span class=keyword>require</span></code>
expression are resolved with respect to the namespace's module. New
<code class=scheme><span class=keyword>provide</span></code> declarations are not allowed.</p>
<p>
<a name="node_idx_1360"></a><a name="node_kw_definitionnamespace-syntax-introduce"></a><code class=scheme>(namespace-syntax-introduce</code><tt>&nbsp;</tt><code class=scheme><span class=variable>stx</span></code><code class=scheme>)</code> returns a syntax object like
<code class=scheme><span class=variable>stx</span></code>, except that the current namespace's bindings are included
in the syntax object's context (see section&nbsp;<a href="mzscheme-Z-H-12.html#node_sec_12.3">12.3</a>). The
additional context is overridden by any existing top-level context in
the syntax object, or by any existing or future module context. See
section&nbsp;<a href="mzscheme-Z-H-12.html#node_sec_12.2">12.2</a> for more information about syntax objects.</p>
<p>
</p>
<p>
</p>
<div class=footnoterule><hr></div><p></p>
<div class=footnote><p><a name="footnote_Temp_16"></a><a href="#call_footnote_Temp_16"><sup><small>13</small></sup></a> The resulting namespace contains syntax
imports for <code class=scheme><span class=keyword>#%app</span></code>, <code class=scheme><span class=keyword>#%datum</span></code>, and <code class=scheme><span class=keyword>#%top</span></code>,
because syntax expansion requires them (see section&nbsp;<a href="mzscheme-Z-H-12.html#node_sec_12.5">12.5</a>), but
those names are not legal <em>R5RS</em> identifiers.</p>
<p><a name="footnote_Temp_17"></a><a href="#call_footnote_Temp_17"><sup><small>14</small></sup></a> More precisely, the current namespace is
used by the evaluation and load handlers, rather than directly by
<code class=scheme><code class=scheme>eval</code></code> and <code class=scheme><code class=scheme>load</code></code>.</p>
</div>
<div align=right class=navigation><i>[Go to <span><a href="mzscheme.html">first</a>, <a href="mzscheme-Z-H-7.html">previous</a></span><span>, <a href="mzscheme-Z-H-9.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="mzscheme.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="mzscheme-Z-H-19.html#node_index_start">index</a></span>]</i></div><p></p>
</body>
</html>
