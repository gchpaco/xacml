<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from mzscheme.tex by tex2page, v 2004-09-11
(running on MzScheme 209, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
PLT MzScheme: Language Manual
</title>
<link rel="stylesheet" type="text/css" href="mzscheme-Z-S.css" title=default>
<meta name=robots content="noindex,follow">
</head>
<body>
<div align=right class=navigation><i>[Go to <span><a href="mzscheme.html">first</a>, <a href="mzscheme-Z-H-9.html">previous</a></span><span>, <a href="mzscheme-Z-H-11.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="mzscheme.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="mzscheme-Z-H-19.html#node_index_start">index</a></span>]</i></div><p></p>
<a name="node_chap_10"></a>
<h1 class=chapter>
<div class=chapterheading><a href="mzscheme.html#node_toc_node_chap_10">Chapter 10</a></div><br>
<a href="mzscheme.html#node_toc_node_chap_10">Regular Expressions</a></h1>
<p><a name="node_idx_1424"></a></p>
<p>
<a name="node_idx_1426"></a>
<a name="node_idx_1428"></a>
<a name="node_idx_1430"></a>
<a name="node_idx_1432"></a>
<a name="node_idx_1434"></a>
MzScheme provides built-in support for regular expression pattern
matching on strings and input ports, built on Henry Spencer's
package. Regular expressions are specified as strings, using the same
pattern language as the Unix utility <tt>egrep</tt>. String-based
regular expressions can be compiled into a <strong>regexp value</strong> for
repeated matches. The internal size of a regexp value is limited to
32 kilobytes; this limit roughly corresponds to a source string with
32,000 literal characters or 5,000 special characters.</p>
<p>
The <tt><strong>pregexp.ss</strong></tt> library of MzLib (see
Chapter&nbsp;<a href="../mzlib/mzlib-Z-H-27.html#node_chap_27">27</a>
in <a href="../mzlib/mzlib.html"><i>PLT MzLib: Libraries Manual</i></a>) provides a similar -- but more
powerful -- form of matching.</p>
<p>

</p>
<p>



</p>
<p>




</p>
<p>
</p>
<a name="node_fig_Temp_20"></a>
<div class=figure align=center><table width=100%><tr><td align=center>
<p>
</p>
<div align=center><table><tr><td>

<tt><p>
<code class=scheme><span class=variable>Regexp</span></code><tt>&nbsp;&nbsp;&nbsp;::=&nbsp;</tt><code class=scheme><span class=variable>Pieces</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Pieces</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Regexp</span></code>|<code class=scheme><span class=variable>Regexp</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match either <code class=scheme><span class=variable>Regexp</span></code>, try left first<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Pieces</span></code><tt>&nbsp;&nbsp;&nbsp;::=&nbsp;</tt><code class=scheme><span class=variable>Piece</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Piece</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Piece</span></code><code class=scheme><span class=variable>Pieces</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match first <code class=scheme><span class=variable>Piece</span></code> followed by second <code class=scheme><span class=variable>Pieces</span></code><tt>&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Piece</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;::=&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code>*<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> 0 or more times, longest possible<tt>&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code>+<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> 1 or more times, longest possible<tt>&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code>?<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> 0 or 1 times, longest possible<tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code>*?<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> 0 or more times, shortest possible<tt></tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code>+?<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> 1 or more times, shortest possible<tt></tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code>??<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> 0 or 1 times, shortest possible<tt>&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Atom</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Atom</span></code> exactly once<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Atom</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::=&nbsp;</tt><tt>(</tt><code class=scheme><span class=variable>Regexp</span></code><tt>)</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match sub-expression <code class=scheme><span class=variable>Regexp</span></code> and report match<tt>&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>(</tt>?:<code class=scheme><span class=variable>Regexp</span></code><tt>)</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match sub-expression <code class=scheme><span class=variable>Regexp</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>[</tt><code class=scheme><span class=variable>Range</span></code><tt>]</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match any character in <code class=scheme><span class=variable>Range</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>[</tt><tt>^</tt><code class=scheme><span class=variable>Range</span></code><tt>]</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match any character not in <code class=scheme><span class=variable>Range</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>.</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match any character<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>^</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match start of string<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt>$<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match end of string<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Literal</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match a single literal character<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Literal</span></code><tt>&nbsp;&nbsp;::=&nbsp;</tt>Any character except (, ), *, +, ?, [, ], ., <tt>^</tt>, \, or |<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt>\<code class=scheme><span class=variable>Aliteral</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>Match <code class=scheme><span class=variable>Aliteral</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Aliteral</span></code><tt>&nbsp;::=&nbsp;</tt>Any character<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Range</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;::=&nbsp;</tt><tt>]</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains ] only<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt>-<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains - only<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>]</tt><code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains ] and everything in <code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt>-<code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains - and everything in <code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Lrange</span></code>-<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains - and everything in <code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><tt>]</tt><code class=scheme><span class=variable>Lrange</span></code>-<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains ], -, and everything in <code class=scheme><span class=variable>Lrange</span></code><tt></tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains everything in <code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;::=&nbsp;</tt><code class=scheme><span class=variable>Rliteral</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains a literal character<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Rliteral</span></code>-<code class=scheme><span class=variable>Rliteral</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains ASCII range inclusive<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Lrange</span></code><code class=scheme><span class=variable>Lrange</span></code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><code class=scheme><span class=variable>Range</span></code> contains everything in both<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>
<code class=scheme><span class=variable>Rliteral</span></code><tt>&nbsp;::=&nbsp;</tt>Any character except ] or -<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> <br>

</p>
</td></tr><tr><td>
<p></p>
</tt>
</td></tr></table></div>

</td></tr>
<tr><td align=center><b>Figure 1:</b>&nbsp;&nbsp;Grammar for regular expressions</td></tr>
<tr><td>
<p>
</p>
</td></tr></table></div><p></p>
<p>
The format of a regular expression is specified by the grammar in
Figure&nbsp;<a href="#node_fig_Temp_20">1</a>. A few subtle points about the regexp
language are worth noting:
</p>
<ul><p>
</p>
<li><p>When an opening square bracket (``['') that starts a range is
immediately followed by a closing square bracket (``]''), then the
closing square bracket is part of the range, instead of ending an
empty range. For example, <code class=scheme><span class=selfeval>&quot;[]a]&quot;</span></code> matches any string that
contains a lowercase ``a'' or a closing square bracket. A dash
(``-'') at the start or end of a range is treated specially in the
same way.</p>
<p>
</p>
<li><p>When a caret (``<tt>^</tt>'') or dollar sign (``$'') appears in
the middle of a regular expression (not in a range), the resulting
regexp is legal even though it is usually not matchable. For example,
<code class=scheme><span class=selfeval>&quot;a$b&quot;</span></code> is unmatchable, because no string can contain the letter
``b'' after the end of the string. In contrast, <code class=scheme><span class=selfeval>&quot;a$b*&quot;</span></code> matches
any string that ends with a lowercase ``a'', since zero ``b''s will
match the part of the regexp after ``$''.</p>
<p>
</p>
<li><p>A backslash (``<tt>\</tt>'') in a regexp pattern specified
with a Scheme string literal must be protected with an additional
backslash.  For example, the string <code class=scheme><span class=selfeval>&quot;\\.&quot;</span></code> describes a
pattern that matches any string containing a period. In this case,
the first backslash protects the second to generate a Scheme string
containing two characters; the second backslash (which is the first
slash in the actual string value) protects the period in the regexp
pattern.</p>
<p>
</p>
</ul><p></p>
<p>
The regular expression procedures are:</p>
<p>
</p>
<ul><p>
</p>
<li><p><a name="node_idx_1436"></a><a name="node_kw_definitionregexp"></a><code class=scheme>(regexp</code><tt>&nbsp;</tt><code class=scheme><span class=variable>string</span></code><code class=scheme>)</code> takes a string representation of a regular
expression and compiles it into a regexp value. Other regular
expression procedures accept either a string or a regexp value as the
matching pattern. If a regular expression string is used multiple
times, it is faster to compile the string once to a regexp value and
use it for repeated matches instead of using the string each time.</p>
<p>
The <code class=scheme><code class=scheme>object-name</code></code> procedure (see section&nbsp;<a href="mzscheme-Z-H-6.html#node_sec_6.2.4">6.2.4</a>) returns
the source string for a regexp value.</p>
<p>
</p>
<li><p><a name="node_idx_1438"></a><a name="node_kw_definitionregexp_Q_"></a><code class=scheme>(regexp?</code><tt>&nbsp;</tt><code class=scheme><span class=variable>v</span></code><code class=scheme>)</code> returns <code class=scheme><span class=selfeval>#t</span></code> if <code class=scheme><span class=variable>v</span></code> is a regexp value
created by <code class=scheme><code class=scheme>regexp</code></code>, <code class=scheme><span class=selfeval>#f</span></code> otherwise.</p>
<p>
</p>
<li><p><a name="node_idx_1440"></a><a name="node_kw_definitionregexp-match"></a><code class=scheme>(regexp-match</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern string</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>start-k end-k output-port</span></code>]<code class=scheme>)</code> 
attempts to match <code class=scheme><span class=variable>pattern</span></code> (a string or a regexp value) to a
portion of <code class=scheme><span class=variable>string</span></code>; see below for information on using an input
port in place of <code class=scheme><span class=variable>string</span></code>.</p>
<p>
The optional <code class=scheme><span class=variable>start-k</span></code> and <code class=scheme><span class=variable>end-k</span></code> arguments select a
substring of <code class=scheme><span class=variable>string</span></code> for matching, and the default is the entire
string. The <code class=scheme><span class=variable>end-k</span></code> argument can be <code class=scheme><span class=selfeval>#f</span></code>, which is the
same as not supplying <code class=scheme><span class=variable>end-k</span></code>. The matcher finds a portion of
<code class=scheme><span class=variable>string</span></code> that matches <code class=scheme><span class=variable>pattern</span></code> and is closest to the start
of the selected substring.</p>
<p>
If the match fails, <code class=scheme><span class=selfeval>#f</span></code> is returned. If the match succeeds, a
list containing strings, and possibly <code class=scheme><span class=selfeval>#f</span></code>, is returned. The
first string in this list is the portion of <code class=scheme><span class=variable>string</span></code> that matched
<code class=scheme><span class=variable>pattern</span></code>. If two portions of <code class=scheme><span class=variable>string</span></code> can match
<code class=scheme><span class=variable>pattern</span></code>, then the match that starts earliest is found.</p>
<p>
Additional strings are returned in the list if <code class=scheme><span class=variable>pattern</span></code> contains
parenthesized sub-expressions (but not when the open parenthesis is
followed by ``?:''). Matches for the sub-expressions are provided in
the order of the opening parentheses in <code class=scheme><span class=variable>pattern</span></code>. When
sub-expressions occur in branches of an ``or'' (``|''), in a ``zero
or more'' pattern (``*''), or in a ``zero or one'' pattern (``?''), a
<code class=scheme><span class=selfeval>#f</span></code> is returned for the expression if it did not contribute
to the final match. When a single sub-expression occurs in a ``zero
or more'' pattern (``*'') or a ``one or more'' pattern (``+'') and is
used multiple times in a match, then the rightmost match associated
with the sub-expression is returned in the list.</p>
<p>
If the optional <code class=scheme><span class=variable>output-port</span></code> is provided, the part of
<code class=scheme><span class=variable>string</span></code> that precedes the match is written to the port. All of
<code class=scheme><span class=variable>string</span></code> up to <code class=scheme><span class=variable>end-k</span></code> is written to the port if no match is
found. This functionality is not especially useful, but it is
provided for consistency with <code class=scheme><code class=scheme>regexp-match</code></code> on input ports.
The <code class=scheme><span class=variable>output-port</span></code> argument can be <code class=scheme><span class=selfeval>#f</span></code>, which is the same
as not supplying it.</p>
<p>
</p>
<li><p><a name="node_idx_1442"></a><a name="node_kw_definitionregexp-match"></a><code class=scheme>(regexp-match</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern input-port</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>start-k end-k output-port</span></code>]<code class=scheme>)</code>
is similar to <code class=scheme><code class=scheme>regexp-match</code></code> with a string (see above), except
that the match is found in the stream of characters produced by
<code class=scheme><span class=variable>input-port</span></code>. The optional <code class=scheme><span class=variable>start-k</span></code> argument indicates the
number of characters to skip before matching <code class=scheme><span class=variable>pattern</span></code>, and
<code class=scheme><span class=variable>end-k</span></code> indicates the maximum number of characters to consider
(including skipped characters). The <code class=scheme><span class=variable>end-k</span></code> argument can be
<code class=scheme><span class=selfeval>#f</span></code>, which is the same as not supplying <code class=scheme><span class=variable>end-k</span></code>. The
default is to skip no characters and read until the end-of-file if
necessary.  If the end-of-file is reached before <code class=scheme><span class=variable>start-k</span></code>
characters are skipped, the match fails.</p>
<p>
In <code class=scheme><span class=variable>pattern</span></code>, a start-of-string caret (``<tt>^</tt>'') refers to
the first read position after skipping, and the end-of-string dollar
sign (``$'') refers to the <code class=scheme><span class=variable>end-k</span></code>th read character or the end
of file, whichever comes first.</p>
<p>
The optional <code class=scheme><span class=variable>output-port</span></code> receives all characters that precede a
match in the input port, or up to <code class=scheme><span class=variable>end-k</span></code> characters (by default
the entire stream) if no match is found.  The <code class=scheme><span class=variable>output-port</span></code>
argument can be <code class=scheme><span class=selfeval>#f</span></code>, which is the same as not supplying it.</p>
<p>
When matching an input port stream, a match failure reads up to
<code class=scheme><span class=variable>end-k</span></code> characters (or end-of-file), even if <code class=scheme><span class=variable>pattern</span></code> begins
with a start-of-string caret (``<tt>^</tt>''); see also
<code class=scheme>regexp-match/fail-without-reading</code> in
Chapter&nbsp;<a href="../mzlib/mzlib-Z-H-34.html#node_chap_34">34</a>
in <a href="../mzlib/mzlib.html"><i>PLT MzLib: Libraries Manual</i></a>. On success, all characters up to and
including the match are eventually read from the port, but matching
proceeds by first peeking characters from the port (using
<code class=scheme><code class=scheme>peek-string-avail!</code></code>; see section&nbsp;<a href="mzscheme-Z-H-11.html#node_sec_11.2.1">11.2.1</a>), and then
(re-)reading matching characters to discard them after the match
result is determined. Non-matching characters may be read and
discarded before the match is determined. The matcher peeks in
blocking mode only as far as necessary to determine a match, but it
may peek extra characters to fill an internal buffer if immediately
available (i.e., without blocking). Greedy repeat operators in
<code class=scheme><span class=variable>pattern</span></code>, such as ``*'' or ``+'', tend to force reading the
entire content of the port (up to <code class=scheme><span class=variable>end-k</span></code>) to determine a match.</p>
<p>
If the port is read simultaneously by another thread, or if the port
is a custom port with inconsistent reading and peeking procedures
(see section&nbsp;<a href="mzscheme-Z-H-11.html#node_sec_11.1.6">11.1.6</a>), then the characters that are peeked and
used for matching may be different than the characters read and
discarded after the match completes. The matcher inspects only the
peeked characters.</p>
<p>
</p>
<li><p><a name="node_idx_1444"></a><a name="node_kw_definitionregexp-match-positions"></a><code class=scheme>(regexp-match-positions</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern string-or-input-port</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>start-k end-k output-port</span></code>]<code class=scheme>)</code>
is like <code class=scheme><code class=scheme>regexp-match</code></code>, but returns a list of number pairs
(and <code class=scheme><span class=selfeval>#f</span></code>) instead of a list of strings. Each pair of numbers
refers to a range of characters in <code class=scheme><span class=variable>string-or-input-port</span></code> in a
<code class=scheme><code class=scheme>substring</code></code>-compatible manner for strings, independent of
<code class=scheme><span class=variable>start-k</span></code>. In the case of an input port, the returned positions
indicate the number of characters that were read, including
<code class=scheme><span class=variable>start-k</span></code>, before the first matching character.</p>
<p>
</p>
<li><p><a name="node_idx_1446"></a><a name="node_kw_definitionregexp-match-peek"></a><code class=scheme>(regexp-match-peek</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern input-port</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>start-k end-k</span></code>]<code class=scheme>)</code>
is like <code class=scheme><code class=scheme>regexp-match</code></code> on input ports, but only peeks
characters from <code class=scheme><span class=variable>input-port</span></code> instead of reading them.</p>
<p>
</p>
<li><p><a name="node_idx_1448"></a><a name="node_kw_definitionregexp-match-peek-positions"></a><code class=scheme>(regexp-match-peek-positions</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern input-port</span></code><tt>&nbsp;</tt>[<code class=scheme><span class=variable>start-k end-k</span></code>]<code class=scheme>)</code>
is like <code class=scheme><code class=scheme>regexp-match-positions</code></code> on input ports, but only
peeks characters from <code class=scheme><span class=variable>input-port</span></code> instead of reading them.</p>
<p>
</p>
<li><p><a name="node_idx_1450"></a><a name="node_kw_definitionregexp-replace"></a><code class=scheme>(regexp-replace</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern string insert-string</span></code><code class=scheme>)</code> performs a
match using <code class=scheme><span class=variable>pattern</span></code> on <code class=scheme><span class=variable>string</span></code> and then returns a string
in which the matching portion of <code class=scheme><span class=variable>string</span></code> is replaced with
<code class=scheme><span class=variable>insert-string</span></code>.  If <code class=scheme><span class=variable>pattern</span></code> matches no part of
<code class=scheme><span class=variable>string</span></code>, then <code class=scheme><span class=variable>string</span></code> is returned unmodified.</p>
<p>
If <code class=scheme><span class=variable>insert-string</span></code> contains ``&amp;'', then ``&amp;'' is replaced with
the matching portion of <code class=scheme><span class=variable>string</span></code> before it is substituted into
<code class=scheme><span class=variable>string</span></code>.  If <code class=scheme><span class=variable>insert-string</span></code> contains
``<tt>\</tt><code class=scheme><span class=variable>n</span></code>'' (for some integer <code class=scheme><span class=variable>n</span></code>), then it is
replaced with the <code class=scheme><span class=variable>n</span></code>th matching sub-expression from
<code class=scheme><span class=variable>string</span></code>.<a name="call_footnote_Temp_21"></a><a href="#footnote_Temp_21"><sup><small>17</small></sup></a> ``&amp;''
and ``<tt>\</tt>0'' are synonymous. If the <code class=scheme><span class=variable>n</span></code>th sub-expression
was not used in the match or if <code class=scheme><span class=variable>n</span></code> is greater than the number of
sub-expressions in <code class=scheme><span class=variable>pattern</span></code>, then ``<tt>\</tt><code class=scheme><span class=variable>n</span></code>'' is
replaced with the empty string.</p>
<p>
A literal ``&amp;'' or ``<tt>\</tt>'' is specified as
``<tt>\</tt>&amp;'' or ``<tt>\</tt><tt>\</tt>'', respectively.  If
<code class=scheme><span class=variable>insert-string</span></code> contains ``<tt>\</tt>$'', then
``<tt>\</tt>$'' is replaced with the empty string. (This can be
used to terminate a number <code class=scheme><span class=variable>n</span></code> following a backslash.) If a
``<tt>\</tt>'' is followed by anything other than a digit, ``&amp;'',
``<tt>\</tt>'', or ``$'', then it is treated as ``<tt>\</tt>0''.</p>
<p>
<a name="node_idx_1452"></a><a name="node_kw_definitionregexp-replace*"></a><code class=scheme>(regexp-replace*</code><tt>&nbsp;</tt><code class=scheme><span class=variable>pattern string insert-string</span></code><code class=scheme>)</code> is the same as
<code class=scheme><code class=scheme>regexp-replace</code></code>, except that every instance of <code class=scheme><span class=variable>pattern</span></code> in
<code class=scheme><span class=variable>string</span></code> is replaced with <code class=scheme><span class=variable>insert-string</span></code>. Only
non-overlapping instances of <code class=scheme><span class=variable>pattern</span></code> in the original
<code class=scheme><span class=variable>string</span></code> are replaced, so instances of <code class=scheme><span class=variable>pattern</span></code> within
inserted strings are <em>not</em> replaced recursively.</p>
<p>
</p>
</ul><p></p>
<p>
Examples:
</p>
<div align=left><pre class=scheme>(<span class=keyword>define</span> <span class=variable>r</span> (<code class=scheme>regexp</code> <span class=selfeval>&quot;(-[0-9]*)+&quot;</span>)) 
(<code class=scheme>regexp-match</code> <span class=variable>r</span> <span class=selfeval>&quot;a-12--345b&quot;</span>) <span class=comment>; =&gt; <code class=scheme><span class=keyword>'</span>(<span class=selfeval>&quot;-12--345&quot;</span> <span class=selfeval>&quot;-345&quot;</span>)</code></span>
(<code class=scheme>regexp-match-positions</code> <span class=variable>r</span> <span class=selfeval>&quot;a-12--345b&quot;</span>) <span class=comment>; =&gt; <code class=scheme><span class=keyword>'</span>((<span class=selfeval>1</span> . <span class=selfeval>10</span>) (<span class=selfeval>5</span> . <span class=selfeval>10</span>))</code></span>
(<code class=scheme>regexp-match</code> <span class=selfeval>&quot;x+&quot;</span> <span class=selfeval>&quot;12345&quot;</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>#f</span></code></span>
(<code class=scheme>regexp-replace</code> <span class=selfeval>&quot;mi&quot;</span> <span class=selfeval>&quot;mi casa&quot;</span> <span class=selfeval>&quot;su&quot;</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>&quot;su casa&quot;</span></code></span>
 
(<span class=keyword>define</span> <span class=variable>r2</span> (<code class=scheme>regexp</code> <span class=selfeval>&quot;([Mm])i ([a-zA-Z]*)&quot;</span>)) 
(<span class=keyword>define</span> <span class=variable>insert</span> <span class=selfeval>&quot;\\1y \\2&quot;</span>) 
(<code class=scheme>regexp-replace</code> <span class=variable>r2</span> <span class=selfeval>&quot;Mi Casa&quot;</span> <span class=variable>insert</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>&quot;My Casa&quot;</span></code></span>
(<code class=scheme>regexp-replace</code> <span class=variable>r2</span> <span class=selfeval>&quot;mi cerveza Mi Mi Mi&quot;</span> <span class=variable>insert</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>&quot;my cerveza Mi Mi Mi&quot;</span></code></span>
(<code class=scheme>regexp-replace*</code> <span class=variable>r2</span> <span class=selfeval>&quot;mi cerveza Mi Mi Mi&quot;</span> <span class=variable>insert</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>&quot;my cerveza My Mi Mi&quot;</span></code></span>
 
(<span class=keyword>define</span> <span class=variable>p</span> (<code class=scheme>open-input-string</code> <span class=selfeval>&quot;a abcd&quot;</span>))
(<code class=scheme>regexp-match-peek</code> <span class=selfeval>&quot;.*bc&quot;</span> <span class=variable>p</span>) <span class=comment>; =&gt; <code class=scheme><span class=keyword>'</span>(<span class=selfeval>&quot;a abc&quot;</span>)</code></span>
(<code class=scheme>regexp-match-peek</code> <span class=selfeval>&quot;.*bc&quot;</span> <span class=variable>p</span> <span class=selfeval>2</span>) <span class=comment>; =&gt; <code class=scheme><span class=keyword>'</span>(<span class=selfeval>&quot;abc&quot;</span>)</code></span>
(<code class=scheme>regexp-match</code> <span class=selfeval>&quot;.*bc&quot;</span> <span class=variable>p</span> <span class=selfeval>2</span>) <span class=comment>; =&gt; <code class=scheme><span class=keyword>'</span>(<span class=selfeval>&quot;abc&quot;</span>)</code></span>
(<code class=scheme>peek-char</code> <span class=variable>p</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>#\d</span></code></span>
(<code class=scheme>regexp-match</code> <span class=selfeval>&quot;.*bc&quot;</span> <span class=variable>p</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>#f</span></code></span>
(<code class=scheme>peek-char</code> <span class=variable>p</span>) <span class=comment>; =&gt; <code class=schemeresponse><span class=selfeval>#&lt;eof&gt;</span></code></span>

(<span class=keyword>define</span> <span class=variable>p</span> (<code class=scheme>open-input-string</code> <span class=selfeval>&quot;aaaaaaaaaaa abcd&quot;</span>))
(<span class=keyword>define</span> <span class=variable>o</span> (<code class=scheme>open-output-string</code>))
(<code class=scheme>regexp-match</code> <span class=selfeval>&quot;abc&quot;</span> <span class=variable>p</span> <span class=selfeval>0</span> <span class=selfeval>#f</span> <span class=variable>o</span>) <span class=comment>; =&gt; <code class=scheme><span class=keyword>'</span>(<span class=selfeval>&quot;abc&quot;</span>)</code></span>
(<code class=scheme>get-output-string</code> <span class=variable>o</span>) <span class=comment>;  =&gt; <code class=schemeresponse><span class=selfeval>&quot;aaaaaaaaaaa &quot;</span></code></span>
</pre></div><p></p>
<p>
</p>
<p>
</p>
<div class=footnoterule><hr></div><p></p>
<div class=footnote><p><a name="footnote_Temp_21"></a><a href="#call_footnote_Temp_21"><sup><small>17</small></sup></a> The backslash is a character in the string, so
an extra backslash is required to specify the string as a Scheme
constant. For example, the Scheme constant
<code class=scheme><span class=selfeval>&quot;\\1&quot;</span></code> is ``<tt>\</tt>1''.</p>
</div>
<div align=right class=navigation><i>[Go to <span><a href="mzscheme.html">first</a>, <a href="mzscheme-Z-H-9.html">previous</a></span><span>, <a href="mzscheme-Z-H-11.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="mzscheme.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="mzscheme-Z-H-19.html#node_index_start">index</a></span>]</i></div><p></p>
</body>
</html>
