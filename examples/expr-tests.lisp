(in-package :xacml-test)(def-test-fixture simplification-fixture ()  ()  (:documentation "Test fixture for expression simplification"))(defmethod setup ((fix simplification-fixture))  t)(defmethod teardown ((fix simplification-fixture))  t)(defmethod and-reduction-test ((fix simplification-fixture))  (let* ((initial '(and (and x y (> z 6)) (< 6 y)))         (result (simplify-expression initial))         (expected '(and x y (> z 6) (< 6 y))))    (unless (equalp result expected)      (failure "Simplification of ~A was ~A, not ~A"               initial result expected))))(defmethod repeated-reduction-test ((fix simplification-fixture))  (let* ((initial '(and (and (and (and x)) y) (< 6 y)))         (result (simplify-until-done initial))         (expected '(and x y (< 6 y))))    (unless (equalp result expected)      (failure "Simplification of ~A was ~A, not ~A"               initial result expected))))(defmethod deep-reduction-test ((fix simplification-fixture))  (let* ((initial '(or (and (and (and x)) y) (< 6 y)))         (result (simplify-until-done initial))         (expected '(or (and x y) (< 6 y))))    (unless (equalp result expected)      (failure "Simplification of ~A was ~A, not ~A"               initial result expected))))(defmethod not-percolation-test ((fix simplification-fixture))  (let* ((initial '(not (or (and (and (and x)) y) (< 6 y))))         (result (simplify-until-done initial))         (expected '(and (or (not x) (not y)) (not (< 6 y)))))    (unless (equalp result expected)      (failure "Simplification of ~A was ~A, not ~A"               initial result expected))))(defmethod cnf-test ((fix simplification-fixture))  (let* ((initial '(and (or (and (and (and x)) y) (< 6 y)) b))         (result (simplify-until-done initial))         (expected '(AND (OR X (< 6 Y)) (OR Y (< 6 Y)) B)))    (unless (equalp result expected)      (failure "Simplification of ~A was ~A, not ~A"               initial result expected)))  (let* ((initial '(or (and (or (or (or x y)) y) (< 6 y)) b))         (result (simplify-until-done initial))         (expected '(OR (AND X (< 6 Y)) (AND Y (< 6 Y)) (AND Y (< 6 Y)) B)))    (unless (equalp result expected)      (failure "Simplification of ~A was ~A, not ~A"               initial result expected))));;; Tests to do:;;; - typing;;; - percolate NOTs up;;; - perhaps transform implies and the usual crowd?(setf simplification-test-suite      (make-test-suite "Simplification Test Suite"                       "Test suite for simplification of expressions"                       ("and reduction" 'simplification-fixture                        :test-thunk 'and-reduction-test                        :description                         "Testing to see whether redundant ANDs are removed")                       ("repeated reduction" 'simplification-fixture                        :test-thunk 'repeated-reduction-test                        :description                        "Testing to see if it can simplify repeatedly")                       ("deep repeated reduction" 'simplification-fixture                        :test-thunk 'deep-reduction-test                        :description                        "Testing to see if it can simplify deep into the tree")                       ("not percolation" 'simplification-fixture                        :test-thunk 'not-percolation-test                        :description                        "Nots should percolate down to the leaves of the tree")                       ("CNF transformation" 'simplification-fixture                        :test-thunk 'cnf-test                        :description                        "The formula should be translated to CNF as far as possible")))(report-result (run-test simplification-test-suite) :verbose t)