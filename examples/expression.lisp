(in-package :xacml)(defun duplicate-reduction (symbol precursor nested postcursor)  "Try to reduce the number of nested levels in EXPRESSION."  (cons symbol (append precursor nested postcursor)))(defun not-reduction (symbol values)  "Invert each expression in VALUES and tie them together with SYMBOL."  (list* symbol (mapcar (lambda (x) (list 'not x))                        values)))(defun curry (function value)  (lambda (&rest values) (apply function value values)))(defun normalize (type inner middle outer)  `(,type ,@(mapcar (lambda (term)                      `(,(if (eq type 'and)                           'or                           'and)                        ,term ,@middle))                    inner)          ,@outer))(defun cnf-normalize (expression)  "Convert EXPRESSION to conjunctive normal form.It is assumed EXPRESSION has already been simplified, and so is in negationnormal form."  (cond ((atom expression) expression)        ((eq (first expression) 'and)         `(and ,@(mapcar #'cnf-normalize (rest expression))))        ((eq (first expression) 'or)         (distribute (mapcar #'cnf-normalize (rest expression))))        (t expression)))(defun distribute (expressions)  "Convert everything in EXPRESSIONS to conjuctive normal form.Each expression in EXPRESSIONS is already in CNF."  ...  (mapcar #'(lambda (term)              ...)          (rest (first expressions))))    (defparameter *simplification-steps*  `(((and ** (and **) **)      . ,(curry #'duplicate-reduction 'and))    ((or ** (or **) **)        . ,(curry #'duplicate-reduction 'or))    ((not (and **))            . ,(curry #'not-reduction 'or))    ((not (or **))             . ,(curry #'not-reduction 'and))    ((or *)                    . ,#'identity)    ((and *)                   . ,#'identity)    ((not (not *))             . ,#'identity)    ;; normal form translation routines    ((and (or (and **) **) **) . ,(curry #'normalize 'and))    ((or (and (or **) **) **)  . ,(curry #'normalize 'or))    )  "Patterns & functions to run when simplifying expressions.")(defun simplify-expression (expression)  "Simplify EXPRESSION by one step."  (if (atom expression)    expression    (let ((result expression))      (dolist (step *simplification-steps* result)        (multiple-value-bind (matched parts)                             (pattern-match-p (car step) expression)          (when matched            (setf result (apply (cdr step) parts))))))))(defun simplify-until-done (expression)  "Repeatedly simplify EXPRESSION until no more simplifications are possible."  (loop for current = (walk-tree expression)         then (walk-tree current)        and previous = expression then current        when (equalp current previous)        do (return current)))(defun walk-tree (expression)  "Try simplifying EXPRESSION and any of its subtrees."  (let* ((first-step (simplify-expression expression))         (current-result '()))    (if (atom first-step)      first-step      (progn        (push (first first-step) current-result)        (dolist (subtree (rest first-step) (nreverse current-result))          (push (walk-tree subtree) current-result))))))